<!doctype html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>定型文コピペ </title>
</head>

<body>
  <div id="root"></div>
</body>

<style>
  .format-box-container {
    box-sizing: border-box;
    width: 100%
  }

  .format-box {
    margin: .6rem 0;
    padding: .6rem;
    background-color: #f2f4e5;
    outline: 2px auto #e7efb1
  }

  .format-flex-container {
    display: flex;
    margin: .3rem 0px
  }

  .format-flex-container>*:first-child {
    margin-right: .6rem
  }

  .format-box-move {
    background-color: #eef3cb;
    flex: 0 0 2rem
  }

  .format-box-move:hover {
    background-color: #dae1b3
  }

  .format-box-move:disabled {
    background-color: #efefef
  }

  .button-container {
    padding: .2rem 0;
    height: 2rem
  }

  .copy-button {
    background-color: #57adf7;
    border: none;
    flex: 1
  }

  .copy-button:hover {
    background-color: #56a7ed
  }

  .copy-button:active {
    background-color: #62b0f5
  }

  .copy-button:active:after {
    padding: 0;
    margin: 0;
    opacity: 1
  }

  .delete-button {
    background-color: #f77d57;
    border: none;
    flex: 0 0 5rem
  }

  .delete-button:hover {
    background-color: #df704e
  }

  .content-dep {
    cursor: pointer
  }

  body {
    padding: .5rem .3rem;
    font-size: 1rem
  }

  .add-button {
    background-color: #39e9a5;
    border: none;
    flex: 1;
    margin-right: .7rem
  }

  .add-button:hover {
    background-color: #3ae1a1
  }

  .restore-button {
    background-color: #e9c13e;
    border: none;
    flex: .7;
    margin-right: .7rem
  }

  .restore-button:hover {
    background-color: #dcb63b
  }

  .restore-button:disabled {
    background-color: #ccc;
    color: #666
  }

  .save-load {
    padding-bottom: 1rem
  }

  .save-load>summary {
    padding: 0 1rem;
    background-color: #62db5c
  }

  button {
    font-size: 1.2rem;
    border-radius: 1rem;
    border: none;
    border: .1px solid #454545;
    background-color: #e6e6e6;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center
  }

  input {
    font-size: 1rem
  }

  .safe-color {
    color: #5266a9;
    font-weight: 700
  }

  .danger-color {
    color: #dc3f3f;
    font-weight: 700
  }
</style>

<script>
  (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o); new MutationObserver(o => { for (const l of o) if (l.type === "childList") for (const i of l.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && r(i); }).observe(document, { childList: !0, subtree: !0 }); function n(o) { const l = {}; return o.integrity && (l.integrity = o.integrity), o.referrerPolicy && (l.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? l.credentials = "include" : o.crossOrigin === "anonymous" ? l.credentials = "omit" : l.credentials = "same-origin", l; } function r(o) { if (o.ep) return; o.ep = !0; const l = n(o); fetch(o.href, l); } })(); function Xc(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e; } var Jc = { exports: {} }, Ul = {}, qc = { exports: {} }, q = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ho = Symbol.for("react.element"), Gh = Symbol.for("react.portal"), Qh = Symbol.for("react.fragment"), Yh = Symbol.for("react.strict_mode"), Zh = Symbol.for("react.profiler"), bh = Symbol.for("react.provider"), Xh = Symbol.for("react.context"), Jh = Symbol.for("react.forward_ref"), qh = Symbol.for("react.suspense"), ev = Symbol.for("react.memo"), tv = Symbol.for("react.lazy"), _a = Symbol.iterator; function nv(e) { return e === null || typeof e != "object" ? null : (e = _a && e[_a] || e["@@iterator"], typeof e == "function" ? e : null); } var ef = { isMounted: function () { return !1; }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, tf = Object.assign, nf = {}; function pr(e, t, n) { this.props = e, this.context = t, this.refs = nf, this.updater = n || ef; } pr.prototype.isReactComponent = {}; pr.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState"); }; pr.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate"); }; function rf() { } rf.prototype = pr.prototype; function ls(e, t, n) { this.props = e, this.context = t, this.refs = nf, this.updater = n || ef; } var is = ls.prototype = new rf; is.constructor = ls; tf(is, pr.prototype); is.isPureReactComponent = !0; var wa = Array.isArray, of = Object.prototype.hasOwnProperty, us = { current: null }, lf = { key: !0, ref: !0, __self: !0, __source: !0 }; function uf(e, t, n) { var r, o = {}, l = null, i = null; if (t != null) for (r in t.ref !== void 0 && (i = t.ref), t.key !== void 0 && (l = "" + t.key), t) of.call(t, r) && !lf.hasOwnProperty(r) && (o[r] = t[r]); var u = arguments.length - 2; if (u === 1) o.children = n; else if (1 < u) { for (var s = Array(u), a = 0; a < u; a++)s[a] = arguments[a + 2]; o.children = s; } if (e && e.defaultProps) for (r in u = e.defaultProps, u) o[r] === void 0 && (o[r] = u[r]); return { $$typeof: ho, type: e, key: l, ref: i, props: o, _owner: us.current }; } function rv(e, t) { return { $$typeof: ho, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner }; } function ss(e) { return typeof e == "object" && e !== null && e.$$typeof === ho; } function ov(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n]; }); } var Ra = /\/+/g; function Ei(e, t) { return typeof e == "object" && e !== null && e.key != null ? ov("" + e.key) : t.toString(36); } function Xo(e, t, n, r, o) { var l = typeof e; (l === "undefined" || l === "boolean") && (e = null); var i = !1; if (e === null) i = !0; else switch (l) { case "string": case "number": i = !0; break; case "object": switch (e.$$typeof) { case ho: case Gh: i = !0; } }if (i) return i = e, o = o(i), e = r === "" ? "." + Ei(i, 0) : r, wa(o) ? (n = "", e != null && (n = e.replace(Ra, "$&/") + "/"), Xo(o, t, n, "", function (a) { return a; })) : o != null && (ss(o) && (o = rv(o, n + (!o.key || i && i.key === o.key ? "" : ("" + o.key).replace(Ra, "$&/") + "/") + e)), t.push(o)), 1; if (i = 0, r = r === "" ? "." : r + ":", wa(e)) for (var u = 0; u < e.length; u++) { l = e[u]; var s = r + Ei(l, u); i += Xo(l, t, n, s, o); } else if (s = nv(e), typeof s == "function") for (e = s.call(e), u = 0; !(l = e.next()).done;)l = l.value, s = r + Ei(l, u++), i += Xo(l, t, n, s, o); else if (l === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return i; } function Ao(e, t, n) { if (e == null) return e; var r = [], o = 0; return Xo(e, r, "", "", function (l) { return t.call(n, l, o++); }), r; } function lv(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n); }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n); }), e._status === -1 && (e._status = 0, e._result = t); } if (e._status === 1) return e._result.default; throw e._result; } var Fe = { current: null }, Jo = { transition: null }, iv = { ReactCurrentDispatcher: Fe, ReactCurrentBatchConfig: Jo, ReactCurrentOwner: us }; q.Children = { map: Ao, forEach: function (e, t, n) { Ao(e, function () { t.apply(this, arguments); }, n); }, count: function (e) { var t = 0; return Ao(e, function () { t++; }), t; }, toArray: function (e) { return Ao(e, function (t) { return t; }) || []; }, only: function (e) { if (!ss(e)) throw Error("React.Children.only expected to receive a single React element child."); return e; } }; q.Component = pr; q.Fragment = Qh; q.Profiler = Zh; q.PureComponent = ls; q.StrictMode = Yh; q.Suspense = qh; q.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = iv; q.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = tf({}, e.props), o = e.key, l = e.ref, i = e._owner; if (t != null) { if (t.ref !== void 0 && (l = t.ref, i = us.current), t.key !== void 0 && (o = "" + t.key), e.type && e.type.defaultProps) var u = e.type.defaultProps; for (s in t) of.call(t, s) && !lf.hasOwnProperty(s) && (r[s] = t[s] === void 0 && u !== void 0 ? u[s] : t[s]); } var s = arguments.length - 2; if (s === 1) r.children = n; else if (1 < s) { u = Array(s); for (var a = 0; a < s; a++)u[a] = arguments[a + 2]; r.children = u; } return { $$typeof: ho, type: e.type, key: o, ref: l, props: r, _owner: i }; }; q.createContext = function (e) { return e = { $$typeof: Xh, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: bh, _context: e }, e.Consumer = e; }; q.createElement = uf; q.createFactory = function (e) { var t = uf.bind(null, e); return t.type = e, t; }; q.createRef = function () { return { current: null }; }; q.forwardRef = function (e) { return { $$typeof: Jh, render: e }; }; q.isValidElement = ss; q.lazy = function (e) { return { $$typeof: tv, _payload: { _status: -1, _result: e }, _init: lv }; }; q.memo = function (e, t) { return { $$typeof: ev, type: e, compare: t === void 0 ? null : t }; }; q.startTransition = function (e) { var t = Jo.transition; Jo.transition = {}; try { e(); } finally { Jo.transition = t; } }; q.unstable_act = function () { throw Error("act(...) is not supported in production builds of React."); }; q.useCallback = function (e, t) { return Fe.current.useCallback(e, t); }; q.useContext = function (e) { return Fe.current.useContext(e); }; q.useDebugValue = function () { }; q.useDeferredValue = function (e) { return Fe.current.useDeferredValue(e); }; q.useEffect = function (e, t) { return Fe.current.useEffect(e, t); }; q.useId = function () { return Fe.current.useId(); }; q.useImperativeHandle = function (e, t, n) { return Fe.current.useImperativeHandle(e, t, n); }; q.useInsertionEffect = function (e, t) { return Fe.current.useInsertionEffect(e, t); }; q.useLayoutEffect = function (e, t) { return Fe.current.useLayoutEffect(e, t); }; q.useMemo = function (e, t) { return Fe.current.useMemo(e, t); }; q.useReducer = function (e, t, n) { return Fe.current.useReducer(e, t, n); }; q.useRef = function (e) { return Fe.current.useRef(e); }; q.useState = function (e) { return Fe.current.useState(e); }; q.useSyncExternalStore = function (e, t, n) { return Fe.current.useSyncExternalStore(e, t, n); }; q.useTransition = function () { return Fe.current.useTransition(); }; q.version = "18.2.0"; qc.exports = q; var er = qc.exports; const ce = Xc(er);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var uv = er, sv = Symbol.for("react.element"), av = Symbol.for("react.fragment"), cv = Object.prototype.hasOwnProperty, fv = uv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, dv = { key: !0, ref: !0, __self: !0, __source: !0 }; function sf(e, t, n) { var r, o = {}, l = null, i = null; n !== void 0 && (l = "" + n), t.key !== void 0 && (l = "" + t.key), t.ref !== void 0 && (i = t.ref); for (r in t) cv.call(t, r) && !dv.hasOwnProperty(r) && (o[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) o[r] === void 0 && (o[r] = t[r]); return { $$typeof: sv, type: e, key: l, ref: i, props: o, _owner: fv.current }; } Ul.Fragment = av; Ul.jsx = sf; Ul.jsxs = sf; Jc.exports = Ul; var Q = Jc.exports, ru = {}, af = { exports: {} }, nt = {}, cf = { exports: {} }, ff = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(M, j) { var $ = M.length; M.push(j); e: for (; 0 < $;) { var O = $ - 1 >>> 1, y = M[O]; if (0 < o(y, j)) M[O] = j, M[$] = y, $ = O; else break e; } } function n(M) { return M.length === 0 ? null : M[0]; } function r(M) { if (M.length === 0) return null; var j = M[0], $ = M.pop(); if ($ !== j) { M[0] = $; e: for (var O = 0, y = M.length, N = y >>> 1; O < N;) { var A = 2 * (O + 1) - 1, K = M[A], V = A + 1, Z = M[V]; if (0 > o(K, $)) V < y && 0 > o(Z, K) ? (M[O] = Z, M[V] = $, O = V) : (M[O] = K, M[A] = $, O = A); else if (V < y && 0 > o(Z, $)) M[O] = Z, M[V] = $, O = V; else break e; } } return j; } function o(M, j) { var $ = M.sortIndex - j.sortIndex; return $ !== 0 ? $ : M.id - j.id; } if (typeof performance == "object" && typeof performance.now == "function") { var l = performance; e.unstable_now = function () { return l.now(); }; } else { var i = Date, u = i.now(); e.unstable_now = function () { return i.now() - u; }; } var s = [], a = [], f = 1, p = null, m = 3, _ = !1, S = !1, w = !1, B = typeof setTimeout == "function" ? setTimeout : null, h = typeof clearTimeout == "function" ? clearTimeout : null, c = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function d(M) { for (var j = n(a); j !== null;) { if (j.callback === null) r(a); else if (j.startTime <= M) r(a), j.sortIndex = j.expirationTime, t(s, j); else break; j = n(a); } } function R(M) { if (w = !1, d(M), !S) if (n(s) !== null) S = !0, $e(k); else { var j = n(a); j !== null && be(R, j.startTime - M); } } function k(M, j) { S = !1, w && (w = !1, h(I), I = -1), _ = !0; var $ = m; try { for (d(j), p = n(s); p !== null && (!(p.expirationTime > j) || M && !fe());) { var O = p.callback; if (typeof O == "function") { p.callback = null, m = p.priorityLevel; var y = O(p.expirationTime <= j); j = e.unstable_now(), typeof y == "function" ? p.callback = y : p === n(s) && r(s), d(j); } else r(s); p = n(s); } if (p !== null) var N = !0; else { var A = n(a); A !== null && be(R, A.startTime - j), N = !1; } return N; } finally { p = null, m = $, _ = !1; } } var C = !1, L = null, I = -1, te = 5, U = -1; function fe() { return !(e.unstable_now() - U < te); } function ot() { if (L !== null) { var M = e.unstable_now(); U = M; var j = !0; try { j = L(!0, M); } finally { j ? re() : (C = !1, L = null); } } else C = !1; } var re; if (typeof c == "function") re = function () { c(ot); }; else if (typeof MessageChannel < "u") { var Me = new MessageChannel, xt = Me.port2; Me.port1.onmessage = ot, re = function () { xt.postMessage(null); }; } else re = function () { B(ot, 0); }; function $e(M) { L = M, C || (C = !0, re()); } function be(M, j) { I = B(function () { M(e.unstable_now()); }, j); } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (M) { M.callback = null; }, e.unstable_continueExecution = function () { S || _ || (S = !0, $e(k)); }, e.unstable_forceFrameRate = function (M) { 0 > M || 125 < M ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : te = 0 < M ? Math.floor(1e3 / M) : 5; }, e.unstable_getCurrentPriorityLevel = function () { return m; }, e.unstable_getFirstCallbackNode = function () { return n(s); }, e.unstable_next = function (M) { switch (m) { case 1: case 2: case 3: var j = 3; break; default: j = m; }var $ = m; m = j; try { return M(); } finally { m = $; } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (M, j) { switch (M) { case 1: case 2: case 3: case 4: case 5: break; default: M = 3; }var $ = m; m = M; try { return j(); } finally { m = $; } }, e.unstable_scheduleCallback = function (M, j, $) { var O = e.unstable_now(); switch (typeof $ == "object" && $ !== null ? ($ = $.delay, $ = typeof $ == "number" && 0 < $ ? O + $ : O) : $ = O, M) { case 1: var y = -1; break; case 2: y = 250; break; case 5: y = 1073741823; break; case 4: y = 1e4; break; default: y = 5e3; }return y = $ + y, M = { id: f++, callback: j, priorityLevel: M, startTime: $, expirationTime: y, sortIndex: -1 }, $ > O ? (M.sortIndex = $, t(a, M), n(s) === null && M === n(a) && (w ? (h(I), I = -1) : w = !0, be(R, $ - O))) : (M.sortIndex = y, t(s, M), S || _ || (S = !0, $e(k))), M; }, e.unstable_shouldYield = fe, e.unstable_wrapCallback = function (M) { var j = m; return function () { var $ = m; m = j; try { return M.apply(this, arguments); } finally { m = $; } }; }; })(ff); cf.exports = ff; var pv = cf.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var df = er, tt = pv; function T(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."; } var pf = new Set, br = {}; function Ln(e, t) { tr(e, t), tr(e + "Capture", t); } function tr(e, t) { for (br[e] = t, e = 0; e < t.length; e++)pf.add(t[e]); } var Dt = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ou = Object.prototype.hasOwnProperty, hv = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Ea = {}, Ta = {}; function vv(e) { return ou.call(Ta, e) ? !0 : ou.call(Ea, e) ? !1 : hv.test(e) ? Ta[e] = !0 : (Ea[e] = !0, !1); } function mv(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1; } } function yv(e, t, n, r) { if (t === null || typeof t > "u" || mv(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t; }return !1; } function Be(e, t, n, r, o, l, i) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = l, this.removeEmptyString = i; } var Pe = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { Pe[e] = new Be(e, 0, !1, e, null, !1, !1); });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; Pe[t] = new Be(t, 1, !1, e[1], null, !1, !1); });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { Pe[e] = new Be(e, 2, !1, e.toLowerCase(), null, !1, !1); });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { Pe[e] = new Be(e, 2, !1, e, null, !1, !1); }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { Pe[e] = new Be(e, 3, !1, e.toLowerCase(), null, !1, !1); });["checked", "multiple", "muted", "selected"].forEach(function (e) { Pe[e] = new Be(e, 3, !0, e, null, !1, !1); });["capture", "download"].forEach(function (e) { Pe[e] = new Be(e, 4, !1, e, null, !1, !1); });["cols", "rows", "size", "span"].forEach(function (e) { Pe[e] = new Be(e, 6, !1, e, null, !1, !1); });["rowSpan", "start"].forEach(function (e) { Pe[e] = new Be(e, 5, !1, e.toLowerCase(), null, !1, !1); }); var as = /[\-:]([a-z])/g; function cs(e) { return e[1].toUpperCase(); } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(as, cs); Pe[t] = new Be(t, 1, !1, e, null, !1, !1); }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(as, cs); Pe[t] = new Be(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1); });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(as, cs); Pe[t] = new Be(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1); });["tabIndex", "crossOrigin"].forEach(function (e) { Pe[e] = new Be(e, 1, !1, e.toLowerCase(), null, !1, !1); }); Pe.xlinkHref = new Be("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { Pe[e] = new Be(e, 1, !1, e.toLowerCase(), null, !0, !0); }); function fs(e, t, n, r) { var o = Pe.hasOwnProperty(t) ? Pe[t] : null; (o !== null ? o.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (yv(t, n, o, r) && (n = null), r || o === null ? vv(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : o.mustUseProperty ? e[o.propertyName] = n === null ? o.type === 3 ? !1 : "" : n : (t = o.attributeName, r = o.attributeNamespace, n === null ? e.removeAttribute(t) : (o = o.type, n = o === 3 || o === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))); } var Ft = df.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, xo = Symbol.for("react.element"), Vn = Symbol.for("react.portal"), Dn = Symbol.for("react.fragment"), ds = Symbol.for("react.strict_mode"), lu = Symbol.for("react.profiler"), hf = Symbol.for("react.provider"), vf = Symbol.for("react.context"), ps = Symbol.for("react.forward_ref"), iu = Symbol.for("react.suspense"), uu = Symbol.for("react.suspense_list"), hs = Symbol.for("react.memo"), Wt = Symbol.for("react.lazy"), mf = Symbol.for("react.offscreen"), ka = Symbol.iterator; function _r(e) { return e === null || typeof e != "object" ? null : (e = ka && e[ka] || e["@@iterator"], typeof e == "function" ? e : null); } var Se = Object.assign, Ti; function $r(e) {
    if (Ti === void 0) try { throw Error(); } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); Ti = t && t[1] || ""; } return `
`+ Ti + e;
  } var ki = !1; function Ni(e, t) {
    if (!e || ki) return ""; ki = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error(); }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error(); } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []); } catch (a) { var r = a; } Reflect.construct(e, [], t); } else { try { t.call(); } catch (a) { r = a; } e.call(t.prototype); } else { try { throw Error(); } catch (a) { r = a; } e(); } } catch (a) {
      if (a && r && typeof a.stack == "string") {
        for (var o = a.stack.split(`
`), l = r.stack.split(`
`), i = o.length - 1, u = l.length - 1; 1 <= i && 0 <= u && o[i] !== l[u];)u--; for (; 1 <= i && 0 <= u; i--, u--)if (o[i] !== l[u]) {
          if (i !== 1 || u !== 1) do if (i--, u--, 0 > u || o[i] !== l[u]) {
            var s = `
`+ o[i].replace(" at new ", " at "); return e.displayName && s.includes("<anonymous>") && (s = s.replace("<anonymous>", e.displayName)), s;
          } while (1 <= i && 0 <= u); break;
        }
      }
    } finally { ki = !1, Error.prepareStackTrace = n; } return (e = e ? e.displayName || e.name : "") ? $r(e) : "";
  } function gv(e) { switch (e.tag) { case 5: return $r(e.type); case 16: return $r("Lazy"); case 13: return $r("Suspense"); case 19: return $r("SuspenseList"); case 0: case 2: case 15: return e = Ni(e.type, !1), e; case 11: return e = Ni(e.type.render, !1), e; case 1: return e = Ni(e.type, !0), e; default: return ""; } } function su(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case Dn: return "Fragment"; case Vn: return "Portal"; case lu: return "Profiler"; case ds: return "StrictMode"; case iu: return "Suspense"; case uu: return "SuspenseList"; }if (typeof e == "object") switch (e.$$typeof) { case vf: return (e.displayName || "Context") + ".Consumer"; case hf: return (e._context.displayName || "Context") + ".Provider"; case ps: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case hs: return t = e.displayName || null, t !== null ? t : su(e.type) || "Memo"; case Wt: t = e._payload, e = e._init; try { return su(e(t)); } catch { } }return null; } function Sv(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return su(t); case 8: return t === ds ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; }return null; } function on(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return ""; } } function yf(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio"); } function _v(e) { var t = yf(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var o = n.get, l = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return o.call(this); }, set: function (i) { r = "" + i, l.call(this, i); } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r; }, setValue: function (i) { r = "" + i; }, stopTracking: function () { e._valueTracker = null, delete e[t]; } }; } } function Po(e) { e._valueTracker || (e._valueTracker = _v(e)); } function gf(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = yf(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1; } function cl(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body; } catch { return e.body; } } function au(e, t) { var n = t.checked; return Se({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }); } function Na(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = on(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null }; } function Sf(e, t) { t = t.checked, t != null && fs(e, "checked", t, !1); } function cu(e, t) { Sf(e, t); var n = on(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return; } t.hasOwnProperty("value") ? fu(e, t.type, n) : t.hasOwnProperty("defaultValue") && fu(e, t.type, on(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked); } function Ca(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t; } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n); } function fu(e, t, n) { (t !== "number" || cl(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)); } var Ir = Array.isArray; function Qn(e, t, n, r) { if (e = e.options, t) { t = {}; for (var o = 0; o < n.length; o++)t["$" + n[o]] = !0; for (n = 0; n < e.length; n++)o = t.hasOwnProperty("$" + e[n].value), e[n].selected !== o && (e[n].selected = o), o && r && (e[n].defaultSelected = !0); } else { for (n = "" + on(n), t = null, o = 0; o < e.length; o++) { if (e[o].value === n) { e[o].selected = !0, r && (e[o].defaultSelected = !0); return; } t !== null || e[o].disabled || (t = e[o]); } t !== null && (t.selected = !0); } } function du(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(T(91)); return Se({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }); } function La(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(T(92)); if (Ir(n)) { if (1 < n.length) throw Error(T(93)); n = n[0]; } t = n; } t == null && (t = ""), n = t; } e._wrapperState = { initialValue: on(n) }; } function _f(e, t) { var n = on(t.value), r = on(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r); } function Aa(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t); } function wf(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml"; } } function pu(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? wf(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e; } var Mo, Rf = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, o) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, o); }); } : e; }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (Mo = Mo || document.createElement("div"), Mo.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Mo.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild); } }); function Xr(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return; } } e.textContent = t; } var Ur = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, wv = ["Webkit", "ms", "Moz", "O"]; Object.keys(Ur).forEach(function (e) { wv.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Ur[t] = Ur[e]; }); }); function Ef(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Ur.hasOwnProperty(e) && Ur[e] ? ("" + t).trim() : t + "px"; } function Tf(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, o = Ef(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, o) : e[n] = o; } } var Rv = Se({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function hu(e, t) { if (t) { if (Rv[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(T(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(T(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(T(61)); } if (t.style != null && typeof t.style != "object") throw Error(T(62)); } } function vu(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0; } } var mu = null; function vs(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e; } var yu = null, Yn = null, Zn = null; function xa(e) { if (e = yo(e)) { if (typeof yu != "function") throw Error(T(280)); var t = e.stateNode; t && (t = Wl(t), yu(e.stateNode, e.type, t)); } } function kf(e) { Yn ? Zn ? Zn.push(e) : Zn = [e] : Yn = e; } function Nf() { if (Yn) { var e = Yn, t = Zn; if (Zn = Yn = null, xa(e), t) for (e = 0; e < t.length; e++)xa(t[e]); } } function Cf(e, t) { return e(t); } function Lf() { } var Ci = !1; function Af(e, t, n) { if (Ci) return e(t, n); Ci = !0; try { return Cf(e, t, n); } finally { Ci = !1, (Yn !== null || Zn !== null) && (Lf(), Nf()); } } function Jr(e, t) { var n = e.stateNode; if (n === null) return null; var r = Wl(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1; }if (e) return null; if (n && typeof n != "function") throw Error(T(231, t, typeof n)); return n; } var gu = !1; if (Dt) try { var wr = {}; Object.defineProperty(wr, "passive", { get: function () { gu = !0; } }), window.addEventListener("test", wr, wr), window.removeEventListener("test", wr, wr); } catch { gu = !1; } function Ev(e, t, n, r, o, l, i, u, s) { var a = Array.prototype.slice.call(arguments, 3); try { t.apply(n, a); } catch (f) { this.onError(f); } } var Or = !1, fl = null, dl = !1, Su = null, Tv = { onError: function (e) { Or = !0, fl = e; } }; function kv(e, t, n, r, o, l, i, u, s) { Or = !1, fl = null, Ev.apply(Tv, arguments); } function Nv(e, t, n, r, o, l, i, u, s) { if (kv.apply(this, arguments), Or) { if (Or) { var a = fl; Or = !1, fl = null; } else throw Error(T(198)); dl || (dl = !0, Su = a); } } function An(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e); } return t.tag === 3 ? n : null; } function xf(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated; } return null; } function Pa(e) { if (An(e) !== e) throw Error(T(188)); } function Cv(e) { var t = e.alternate; if (!t) { if (t = An(e), t === null) throw Error(T(188)); return t !== e ? null : e; } for (var n = e, r = t; ;) { var o = n.return; if (o === null) break; var l = o.alternate; if (l === null) { if (r = o.return, r !== null) { n = r; continue; } break; } if (o.child === l.child) { for (l = o.child; l;) { if (l === n) return Pa(o), e; if (l === r) return Pa(o), t; l = l.sibling; } throw Error(T(188)); } if (n.return !== r.return) n = o, r = l; else { for (var i = !1, u = o.child; u;) { if (u === n) { i = !0, n = o, r = l; break; } if (u === r) { i = !0, r = o, n = l; break; } u = u.sibling; } if (!i) { for (u = l.child; u;) { if (u === n) { i = !0, n = l, r = o; break; } if (u === r) { i = !0, r = l, n = o; break; } u = u.sibling; } if (!i) throw Error(T(189)); } } if (n.alternate !== r) throw Error(T(190)); } if (n.tag !== 3) throw Error(T(188)); return n.stateNode.current === n ? e : t; } function Pf(e) { return e = Cv(e), e !== null ? Mf(e) : null; } function Mf(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = Mf(e); if (t !== null) return t; e = e.sibling; } return null; } var $f = tt.unstable_scheduleCallback, Ma = tt.unstable_cancelCallback, Lv = tt.unstable_shouldYield, Av = tt.unstable_requestPaint, we = tt.unstable_now, xv = tt.unstable_getCurrentPriorityLevel, ms = tt.unstable_ImmediatePriority, If = tt.unstable_UserBlockingPriority, pl = tt.unstable_NormalPriority, Pv = tt.unstable_LowPriority, Vf = tt.unstable_IdlePriority, Ol = null, Nt = null; function Mv(e) { if (Nt && typeof Nt.onCommitFiberRoot == "function") try { Nt.onCommitFiberRoot(Ol, e, void 0, (e.current.flags & 128) === 128); } catch { } } var _t = Math.clz32 ? Math.clz32 : Vv, $v = Math.log, Iv = Math.LN2; function Vv(e) { return e >>>= 0, e === 0 ? 32 : 31 - ($v(e) / Iv | 0) | 0; } var $o = 64, Io = 4194304; function Vr(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e; } } function hl(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, o = e.suspendedLanes, l = e.pingedLanes, i = n & 268435455; if (i !== 0) { var u = i & ~o; u !== 0 ? r = Vr(u) : (l &= i, l !== 0 && (r = Vr(l))); } else i = n & ~o, i !== 0 ? r = Vr(i) : l !== 0 && (r = Vr(l)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & o) && (o = r & -r, l = t & -t, o >= l || o === 16 && (l & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - _t(t), o = 1 << n, r |= e[n], t &= ~o; return r; } function Dv(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1; } } function zv(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, o = e.expirationTimes, l = e.pendingLanes; 0 < l;) { var i = 31 - _t(l), u = 1 << i, s = o[i]; s === -1 ? (!(u & n) || u & r) && (o[i] = Dv(u, t)) : s <= t && (e.expiredLanes |= u), l &= ~u; } } function _u(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0; } function Df() { var e = $o; return $o <<= 1, !($o & 4194240) && ($o = 64), e; } function Li(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t; } function vo(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - _t(t), e[t] = n; } function Uv(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var o = 31 - _t(n), l = 1 << o; t[o] = 0, r[o] = -1, e[o] = -1, n &= ~l; } } function ys(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - _t(n), o = 1 << r; o & t | e[r] & t && (e[r] |= t), n &= ~o; } } var ne = 0; function zf(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1; } var Uf, gs, Of, Ff, Bf, wu = !1, Vo = [], bt = null, Xt = null, Jt = null, qr = new Map, eo = new Map, Gt = [], Ov = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function $a(e, t) { switch (e) { case "focusin": case "focusout": bt = null; break; case "dragenter": case "dragleave": Xt = null; break; case "mouseover": case "mouseout": Jt = null; break; case "pointerover": case "pointerout": qr.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": eo.delete(t.pointerId); } } function Rr(e, t, n, r, o, l) { return e === null || e.nativeEvent !== l ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: l, targetContainers: [o] }, t !== null && (t = yo(t), t !== null && gs(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, o !== null && t.indexOf(o) === -1 && t.push(o), e); } function Fv(e, t, n, r, o) { switch (t) { case "focusin": return bt = Rr(bt, e, t, n, r, o), !0; case "dragenter": return Xt = Rr(Xt, e, t, n, r, o), !0; case "mouseover": return Jt = Rr(Jt, e, t, n, r, o), !0; case "pointerover": var l = o.pointerId; return qr.set(l, Rr(qr.get(l) || null, e, t, n, r, o)), !0; case "gotpointercapture": return l = o.pointerId, eo.set(l, Rr(eo.get(l) || null, e, t, n, r, o)), !0; }return !1; } function jf(e) { var t = mn(e.target); if (t !== null) { var n = An(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = xf(n), t !== null) { e.blockedOn = t, Bf(e.priority, function () { Of(n); }); return; } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return; } } } e.blockedOn = null; } function qo(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Ru(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); mu = r, n.target.dispatchEvent(r), mu = null; } else return t = yo(n), t !== null && gs(t), e.blockedOn = n, !1; t.shift(); } return !0; } function Ia(e, t, n) { qo(e) && n.delete(t); } function Bv() { wu = !1, bt !== null && qo(bt) && (bt = null), Xt !== null && qo(Xt) && (Xt = null), Jt !== null && qo(Jt) && (Jt = null), qr.forEach(Ia), eo.forEach(Ia); } function Er(e, t) { e.blockedOn === t && (e.blockedOn = null, wu || (wu = !0, tt.unstable_scheduleCallback(tt.unstable_NormalPriority, Bv))); } function to(e) { function t(o) { return Er(o, e); } if (0 < Vo.length) { Er(Vo[0], e); for (var n = 1; n < Vo.length; n++) { var r = Vo[n]; r.blockedOn === e && (r.blockedOn = null); } } for (bt !== null && Er(bt, e), Xt !== null && Er(Xt, e), Jt !== null && Er(Jt, e), qr.forEach(t), eo.forEach(t), n = 0; n < Gt.length; n++)r = Gt[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < Gt.length && (n = Gt[0], n.blockedOn === null);)jf(n), n.blockedOn === null && Gt.shift(); } var bn = Ft.ReactCurrentBatchConfig, vl = !0; function jv(e, t, n, r) { var o = ne, l = bn.transition; bn.transition = null; try { ne = 1, Ss(e, t, n, r); } finally { ne = o, bn.transition = l; } } function Wv(e, t, n, r) { var o = ne, l = bn.transition; bn.transition = null; try { ne = 4, Ss(e, t, n, r); } finally { ne = o, bn.transition = l; } } function Ss(e, t, n, r) { if (vl) { var o = Ru(e, t, n, r); if (o === null) Ui(e, t, r, ml, n), $a(e, r); else if (Fv(o, e, t, n, r)) r.stopPropagation(); else if ($a(e, r), t & 4 && -1 < Ov.indexOf(e)) { for (; o !== null;) { var l = yo(o); if (l !== null && Uf(l), l = Ru(e, t, n, r), l === null && Ui(e, t, r, ml, n), l === o) break; o = l; } o !== null && r.stopPropagation(); } else Ui(e, t, r, null, n); } } var ml = null; function Ru(e, t, n, r) { if (ml = null, e = vs(r), e = mn(e), e !== null) if (t = An(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = xf(t), e !== null) return e; e = null; } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null; } else t !== e && (e = null); return ml = e, null; } function Wf(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (xv()) { case ms: return 1; case If: return 4; case pl: case Pv: return 16; case Vf: return 536870912; default: return 16; }default: return 16; } } var Yt = null, _s = null, el = null; function Hf() { if (el) return el; var e, t = _s, n = t.length, r, o = "value" in Yt ? Yt.value : Yt.textContent, l = o.length; for (e = 0; e < n && t[e] === o[e]; e++); var i = n - e; for (r = 1; r <= i && t[n - r] === o[l - r]; r++); return el = o.slice(e, 1 < r ? 1 - r : void 0); } function tl(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0; } function Do() { return !0; } function Va() { return !1; } function rt(e) { function t(n, r, o, l, i) { this._reactName = n, this._targetInst = o, this.type = r, this.nativeEvent = l, this.target = i, this.currentTarget = null; for (var u in e) e.hasOwnProperty(u) && (n = e[u], this[u] = n ? n(l) : l[u]); return this.isDefaultPrevented = (l.defaultPrevented != null ? l.defaultPrevented : l.returnValue === !1) ? Do : Va, this.isPropagationStopped = Va, this; } return Se(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Do); }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Do); }, persist: function () { }, isPersistent: Do }), t; } var hr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now(); }, defaultPrevented: 0, isTrusted: 0 }, ws = rt(hr), mo = Se({}, hr, { view: 0, detail: 0 }), Hv = rt(mo), Ai, xi, Tr, Fl = Se({}, mo, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Rs, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget; }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Tr && (Tr && e.type === "mousemove" ? (Ai = e.screenX - Tr.screenX, xi = e.screenY - Tr.screenY) : xi = Ai = 0, Tr = e), Ai); }, movementY: function (e) { return "movementY" in e ? e.movementY : xi; } }), Da = rt(Fl), Kv = Se({}, Fl, { dataTransfer: 0 }), Gv = rt(Kv), Qv = Se({}, mo, { relatedTarget: 0 }), Pi = rt(Qv), Yv = Se({}, hr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Zv = rt(Yv), bv = Se({}, hr, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData; } }), Xv = rt(bv), Jv = Se({}, hr, { data: 0 }), za = rt(Jv), qv = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, em = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, tm = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function nm(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = tm[e]) ? !!t[e] : !1; } function Rs() { return nm; } var rm = Se({}, mo, { key: function (e) { if (e.key) { var t = qv[e.key] || e.key; if (t !== "Unidentified") return t; } return e.type === "keypress" ? (e = tl(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? em[e.keyCode] || "Unidentified" : ""; }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Rs, charCode: function (e) { return e.type === "keypress" ? tl(e) : 0; }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0; }, which: function (e) { return e.type === "keypress" ? tl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0; } }), om = rt(rm), lm = Se({}, Fl, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Ua = rt(lm), im = Se({}, mo, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Rs }), um = rt(im), sm = Se({}, hr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), am = rt(sm), cm = Se({}, Fl, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0; }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0; }, deltaZ: 0, deltaMode: 0 }), fm = rt(cm), dm = [9, 13, 27, 32], Es = Dt && "CompositionEvent" in window, Fr = null; Dt && "documentMode" in document && (Fr = document.documentMode); var pm = Dt && "TextEvent" in window && !Fr, Kf = Dt && (!Es || Fr && 8 < Fr && 11 >= Fr), Oa = " ", Fa = !1; function Gf(e, t) { switch (e) { case "keyup": return dm.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1; } } function Qf(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null; } var zn = !1; function hm(e, t) { switch (e) { case "compositionend": return Qf(t); case "keypress": return t.which !== 32 ? null : (Fa = !0, Oa); case "textInput": return e = t.data, e === Oa && Fa ? null : e; default: return null; } } function vm(e, t) { if (zn) return e === "compositionend" || !Es && Gf(e, t) ? (e = Hf(), el = _s = Yt = null, zn = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which); } return null; case "compositionend": return Kf && t.locale !== "ko" ? null : t.data; default: return null; } } var mm = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Ba(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!mm[e.type] : t === "textarea"; } function Yf(e, t, n, r) { kf(r), t = yl(t, "onChange"), 0 < t.length && (n = new ws("onChange", "change", null, n, r), e.push({ event: n, listeners: t })); } var Br = null, no = null; function ym(e) { ld(e, 0); } function Bl(e) { var t = Fn(e); if (gf(t)) return e; } function gm(e, t) { if (e === "change") return t; } var Zf = !1; if (Dt) { var Mi; if (Dt) { var $i = "oninput" in document; if (!$i) { var ja = document.createElement("div"); ja.setAttribute("oninput", "return;"), $i = typeof ja.oninput == "function"; } Mi = $i; } else Mi = !1; Zf = Mi && (!document.documentMode || 9 < document.documentMode); } function Wa() { Br && (Br.detachEvent("onpropertychange", bf), no = Br = null); } function bf(e) { if (e.propertyName === "value" && Bl(no)) { var t = []; Yf(t, no, e, vs(e)), Af(ym, t); } } function Sm(e, t, n) { e === "focusin" ? (Wa(), Br = t, no = n, Br.attachEvent("onpropertychange", bf)) : e === "focusout" && Wa(); } function _m(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Bl(no); } function wm(e, t) { if (e === "click") return Bl(t); } function Rm(e, t) { if (e === "input" || e === "change") return Bl(t); } function Em(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t; } var Rt = typeof Object.is == "function" ? Object.is : Em; function ro(e, t) { if (Rt(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var o = n[r]; if (!ou.call(t, o) || !Rt(e[o], t[o])) return !1; } return !0; } function Ha(e) { for (; e && e.firstChild;)e = e.firstChild; return e; } function Ka(e, t) { var n = Ha(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r; } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e; } n = n.parentNode; } n = void 0; } n = Ha(n); } } function Xf(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Xf(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1; } function Jf() { for (var e = window, t = cl(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string"; } catch { n = !1; } if (n) e = t.contentWindow; else break; t = cl(e.document); } return t; } function Ts(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true"); } function Tm(e) { var t = Jf(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && Xf(n.ownerDocument.documentElement, n)) { if (r !== null && Ts(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var o = n.textContent.length, l = Math.min(r.start, o); r = r.end === void 0 ? l : Math.min(r.end, o), !e.extend && l > r && (o = r, r = l, l = o), o = Ka(n, l); var i = Ka(n, r); o && i && (e.rangeCount !== 1 || e.anchorNode !== o.node || e.anchorOffset !== o.offset || e.focusNode !== i.node || e.focusOffset !== i.offset) && (t = t.createRange(), t.setStart(o.node, o.offset), e.removeAllRanges(), l > r ? (e.addRange(t), e.extend(i.node, i.offset)) : (t.setEnd(i.node, i.offset), e.addRange(t))); } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top; } } var km = Dt && "documentMode" in document && 11 >= document.documentMode, Un = null, Eu = null, jr = null, Tu = !1; function Ga(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Tu || Un == null || Un !== cl(r) || (r = Un, "selectionStart" in r && Ts(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), jr && ro(jr, r) || (jr = r, r = yl(Eu, "onSelect"), 0 < r.length && (t = new ws("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = Un))); } function zo(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n; } var On = { animationend: zo("Animation", "AnimationEnd"), animationiteration: zo("Animation", "AnimationIteration"), animationstart: zo("Animation", "AnimationStart"), transitionend: zo("Transition", "TransitionEnd") }, Ii = {}, qf = {}; Dt && (qf = document.createElement("div").style, "AnimationEvent" in window || (delete On.animationend.animation, delete On.animationiteration.animation, delete On.animationstart.animation), "TransitionEvent" in window || delete On.transitionend.transition); function jl(e) { if (Ii[e]) return Ii[e]; if (!On[e]) return e; var t = On[e], n; for (n in t) if (t.hasOwnProperty(n) && n in qf) return Ii[e] = t[n]; return e; } var ed = jl("animationend"), td = jl("animationiteration"), nd = jl("animationstart"), rd = jl("transitionend"), od = new Map, Qa = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function un(e, t) { od.set(e, t), Ln(t, [e]); } for (var Vi = 0; Vi < Qa.length; Vi++) { var Di = Qa[Vi], Nm = Di.toLowerCase(), Cm = Di[0].toUpperCase() + Di.slice(1); un(Nm, "on" + Cm); } un(ed, "onAnimationEnd"); un(td, "onAnimationIteration"); un(nd, "onAnimationStart"); un("dblclick", "onDoubleClick"); un("focusin", "onFocus"); un("focusout", "onBlur"); un(rd, "onTransitionEnd"); tr("onMouseEnter", ["mouseout", "mouseover"]); tr("onMouseLeave", ["mouseout", "mouseover"]); tr("onPointerEnter", ["pointerout", "pointerover"]); tr("onPointerLeave", ["pointerout", "pointerover"]); Ln("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Ln("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Ln("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Ln("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Ln("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Ln("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Dr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Lm = new Set("cancel close invalid load scroll toggle".split(" ").concat(Dr)); function Ya(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, Nv(r, t, void 0, e), e.currentTarget = null; } function ld(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], o = r.event; r = r.listeners; e: { var l = void 0; if (t) for (var i = r.length - 1; 0 <= i; i--) { var u = r[i], s = u.instance, a = u.currentTarget; if (u = u.listener, s !== l && o.isPropagationStopped()) break e; Ya(o, u, a), l = s; } else for (i = 0; i < r.length; i++) { if (u = r[i], s = u.instance, a = u.currentTarget, u = u.listener, s !== l && o.isPropagationStopped()) break e; Ya(o, u, a), l = s; } } } if (dl) throw e = Su, dl = !1, Su = null, e; } function ue(e, t) { var n = t[Au]; n === void 0 && (n = t[Au] = new Set); var r = e + "__bubble"; n.has(r) || (id(t, e, 2, !1), n.add(r)); } function zi(e, t, n) { var r = 0; t && (r |= 4), id(n, e, r, t); } var Uo = "_reactListening" + Math.random().toString(36).slice(2); function oo(e) { if (!e[Uo]) { e[Uo] = !0, pf.forEach(function (n) { n !== "selectionchange" && (Lm.has(n) || zi(n, !1, e), zi(n, !0, e)); }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[Uo] || (t[Uo] = !0, zi("selectionchange", !1, t)); } } function id(e, t, n, r) { switch (Wf(t)) { case 1: var o = jv; break; case 4: o = Wv; break; default: o = Ss; }n = o.bind(null, t, n, e), o = void 0, !gu || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (o = !0), r ? o !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: o }) : e.addEventListener(t, n, !0) : o !== void 0 ? e.addEventListener(t, n, { passive: o }) : e.addEventListener(t, n, !1); } function Ui(e, t, n, r, o) { var l = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var i = r.tag; if (i === 3 || i === 4) { var u = r.stateNode.containerInfo; if (u === o || u.nodeType === 8 && u.parentNode === o) break; if (i === 4) for (i = r.return; i !== null;) { var s = i.tag; if ((s === 3 || s === 4) && (s = i.stateNode.containerInfo, s === o || s.nodeType === 8 && s.parentNode === o)) return; i = i.return; } for (; u !== null;) { if (i = mn(u), i === null) return; if (s = i.tag, s === 5 || s === 6) { r = l = i; continue e; } u = u.parentNode; } } r = r.return; } Af(function () { var a = l, f = vs(n), p = []; e: { var m = od.get(e); if (m !== void 0) { var _ = ws, S = e; switch (e) { case "keypress": if (tl(n) === 0) break e; case "keydown": case "keyup": _ = om; break; case "focusin": S = "focus", _ = Pi; break; case "focusout": S = "blur", _ = Pi; break; case "beforeblur": case "afterblur": _ = Pi; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": _ = Da; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": _ = Gv; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": _ = um; break; case ed: case td: case nd: _ = Zv; break; case rd: _ = am; break; case "scroll": _ = Hv; break; case "wheel": _ = fm; break; case "copy": case "cut": case "paste": _ = Xv; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": _ = Ua; }var w = (t & 4) !== 0, B = !w && e === "scroll", h = w ? m !== null ? m + "Capture" : null : m; w = []; for (var c = a, d; c !== null;) { d = c; var R = d.stateNode; if (d.tag === 5 && R !== null && (d = R, h !== null && (R = Jr(c, h), R != null && w.push(lo(c, R, d)))), B) break; c = c.return; } 0 < w.length && (m = new _(m, S, null, n, f), p.push({ event: m, listeners: w })); } } if (!(t & 7)) { e: { if (m = e === "mouseover" || e === "pointerover", _ = e === "mouseout" || e === "pointerout", m && n !== mu && (S = n.relatedTarget || n.fromElement) && (mn(S) || S[zt])) break e; if ((_ || m) && (m = f.window === f ? f : (m = f.ownerDocument) ? m.defaultView || m.parentWindow : window, _ ? (S = n.relatedTarget || n.toElement, _ = a, S = S ? mn(S) : null, S !== null && (B = An(S), S !== B || S.tag !== 5 && S.tag !== 6) && (S = null)) : (_ = null, S = a), _ !== S)) { if (w = Da, R = "onMouseLeave", h = "onMouseEnter", c = "mouse", (e === "pointerout" || e === "pointerover") && (w = Ua, R = "onPointerLeave", h = "onPointerEnter", c = "pointer"), B = _ == null ? m : Fn(_), d = S == null ? m : Fn(S), m = new w(R, c + "leave", _, n, f), m.target = B, m.relatedTarget = d, R = null, mn(f) === a && (w = new w(h, c + "enter", S, n, f), w.target = d, w.relatedTarget = B, R = w), B = R, _ && S) t: { for (w = _, h = S, c = 0, d = w; d; d = $n(d))c++; for (d = 0, R = h; R; R = $n(R))d++; for (; 0 < c - d;)w = $n(w), c--; for (; 0 < d - c;)h = $n(h), d--; for (; c--;) { if (w === h || h !== null && w === h.alternate) break t; w = $n(w), h = $n(h); } w = null; } else w = null; _ !== null && Za(p, m, _, w, !1), S !== null && B !== null && Za(p, B, S, w, !0); } } e: { if (m = a ? Fn(a) : window, _ = m.nodeName && m.nodeName.toLowerCase(), _ === "select" || _ === "input" && m.type === "file") var k = gm; else if (Ba(m)) if (Zf) k = Rm; else { k = _m; var C = Sm; } else (_ = m.nodeName) && _.toLowerCase() === "input" && (m.type === "checkbox" || m.type === "radio") && (k = wm); if (k && (k = k(e, a))) { Yf(p, k, n, f); break e; } C && C(e, m, a), e === "focusout" && (C = m._wrapperState) && C.controlled && m.type === "number" && fu(m, "number", m.value); } switch (C = a ? Fn(a) : window, e) { case "focusin": (Ba(C) || C.contentEditable === "true") && (Un = C, Eu = a, jr = null); break; case "focusout": jr = Eu = Un = null; break; case "mousedown": Tu = !0; break; case "contextmenu": case "mouseup": case "dragend": Tu = !1, Ga(p, n, f); break; case "selectionchange": if (km) break; case "keydown": case "keyup": Ga(p, n, f); }var L; if (Es) e: { switch (e) { case "compositionstart": var I = "onCompositionStart"; break e; case "compositionend": I = "onCompositionEnd"; break e; case "compositionupdate": I = "onCompositionUpdate"; break e; }I = void 0; } else zn ? Gf(e, n) && (I = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (I = "onCompositionStart"); I && (Kf && n.locale !== "ko" && (zn || I !== "onCompositionStart" ? I === "onCompositionEnd" && zn && (L = Hf()) : (Yt = f, _s = "value" in Yt ? Yt.value : Yt.textContent, zn = !0)), C = yl(a, I), 0 < C.length && (I = new za(I, e, null, n, f), p.push({ event: I, listeners: C }), L ? I.data = L : (L = Qf(n), L !== null && (I.data = L)))), (L = pm ? hm(e, n) : vm(e, n)) && (a = yl(a, "onBeforeInput"), 0 < a.length && (f = new za("onBeforeInput", "beforeinput", null, n, f), p.push({ event: f, listeners: a }), f.data = L)); } ld(p, t); }); } function lo(e, t, n) { return { instance: e, listener: t, currentTarget: n }; } function yl(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var o = e, l = o.stateNode; o.tag === 5 && l !== null && (o = l, l = Jr(e, n), l != null && r.unshift(lo(e, l, o)), l = Jr(e, t), l != null && r.push(lo(e, l, o))), e = e.return; } return r; } function $n(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null; } function Za(e, t, n, r, o) { for (var l = t._reactName, i = []; n !== null && n !== r;) { var u = n, s = u.alternate, a = u.stateNode; if (s !== null && s === r) break; u.tag === 5 && a !== null && (u = a, o ? (s = Jr(n, l), s != null && i.unshift(lo(n, s, u))) : o || (s = Jr(n, l), s != null && i.push(lo(n, s, u)))), n = n.return; } i.length !== 0 && e.push({ event: t, listeners: i }); } var Am = /\r\n?/g, xm = /\u0000|\uFFFD/g; function ba(e) {
    return (typeof e == "string" ? e : "" + e).replace(Am, `
`).replace(xm, "");
  } function Oo(e, t, n) { if (t = ba(t), ba(e) !== t && n) throw Error(T(425)); } function gl() { } var ku = null, Nu = null; function Cu(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null; } var Lu = typeof setTimeout == "function" ? setTimeout : void 0, Pm = typeof clearTimeout == "function" ? clearTimeout : void 0, Xa = typeof Promise == "function" ? Promise : void 0, Mm = typeof queueMicrotask == "function" ? queueMicrotask : typeof Xa < "u" ? function (e) { return Xa.resolve(null).then(e).catch($m); } : Lu; function $m(e) { setTimeout(function () { throw e; }); } function Oi(e, t) { var n = t, r = 0; do { var o = n.nextSibling; if (e.removeChild(n), o && o.nodeType === 8) if (n = o.data, n === "/$") { if (r === 0) { e.removeChild(o), to(t); return; } r--; } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = o; } while (n); to(t); } function qt(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null; } } return e; } function Ja(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t--; } else n === "/$" && t++; } e = e.previousSibling; } return null; } var vr = Math.random().toString(36).slice(2), kt = "__reactFiber$" + vr, io = "__reactProps$" + vr, zt = "__reactContainer$" + vr, Au = "__reactEvents$" + vr, Im = "__reactListeners$" + vr, Vm = "__reactHandles$" + vr; function mn(e) { var t = e[kt]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[zt] || n[kt]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Ja(e); e !== null;) { if (n = e[kt]) return n; e = Ja(e); } return t; } e = n, n = e.parentNode; } return null; } function yo(e) { return e = e[kt] || e[zt], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e; } function Fn(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(T(33)); } function Wl(e) { return e[io] || null; } var xu = [], Bn = -1; function sn(e) { return { current: e }; } function ae(e) { 0 > Bn || (e.current = xu[Bn], xu[Bn] = null, Bn--); } function ie(e, t) { Bn++, xu[Bn] = e.current, e.current = t; } var ln = {}, ze = sn(ln), Ke = sn(!1), wn = ln; function nr(e, t) { var n = e.type.contextTypes; if (!n) return ln; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var o = {}, l; for (l in n) o[l] = t[l]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o; } function Ge(e) { return e = e.childContextTypes, e != null; } function Sl() { ae(Ke), ae(ze); } function qa(e, t, n) { if (ze.current !== ln) throw Error(T(168)); ie(ze, t), ie(Ke, n); } function ud(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var o in r) if (!(o in t)) throw Error(T(108, Sv(e) || "Unknown", o)); return Se({}, n, r); } function _l(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ln, wn = ze.current, ie(ze, e), ie(Ke, Ke.current), !0; } function ec(e, t, n) { var r = e.stateNode; if (!r) throw Error(T(169)); n ? (e = ud(e, t, wn), r.__reactInternalMemoizedMergedChildContext = e, ae(Ke), ae(ze), ie(ze, e)) : ae(Ke), ie(Ke, n); } var Mt = null, Hl = !1, Fi = !1; function sd(e) { Mt === null ? Mt = [e] : Mt.push(e); } function Dm(e) { Hl = !0, sd(e); } function an() { if (!Fi && Mt !== null) { Fi = !0; var e = 0, t = ne; try { var n = Mt; for (ne = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null); } Mt = null, Hl = !1; } catch (o) { throw Mt !== null && (Mt = Mt.slice(e + 1)), $f(ms, an), o; } finally { ne = t, Fi = !1; } } return null; } var jn = [], Wn = 0, wl = null, Rl = 0, ut = [], st = 0, Rn = null, $t = 1, It = ""; function pn(e, t) { jn[Wn++] = Rl, jn[Wn++] = wl, wl = e, Rl = t; } function ad(e, t, n) { ut[st++] = $t, ut[st++] = It, ut[st++] = Rn, Rn = e; var r = $t; e = It; var o = 32 - _t(r) - 1; r &= ~(1 << o), n += 1; var l = 32 - _t(t) + o; if (30 < l) { var i = o - o % 5; l = (r & (1 << i) - 1).toString(32), r >>= i, o -= i, $t = 1 << 32 - _t(t) + o | n << o | r, It = l + e; } else $t = 1 << l | n << o | r, It = e; } function ks(e) { e.return !== null && (pn(e, 1), ad(e, 1, 0)); } function Ns(e) { for (; e === wl;)wl = jn[--Wn], jn[Wn] = null, Rl = jn[--Wn], jn[Wn] = null; for (; e === Rn;)Rn = ut[--st], ut[st] = null, It = ut[--st], ut[st] = null, $t = ut[--st], ut[st] = null; } var et = null, qe = null, he = !1, St = null; function cd(e, t) { var n = at(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n); } function tc(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, et = e, qe = qt(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, et = e, qe = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = Rn !== null ? { id: $t, overflow: It } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = at(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, et = e, qe = null, !0) : !1; default: return !1; } } function Pu(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0; } function Mu(e) { if (he) { var t = qe; if (t) { var n = t; if (!tc(e, t)) { if (Pu(e)) throw Error(T(418)); t = qt(n.nextSibling); var r = et; t && tc(e, t) ? cd(r, n) : (e.flags = e.flags & -4097 | 2, he = !1, et = e); } } else { if (Pu(e)) throw Error(T(418)); e.flags = e.flags & -4097 | 2, he = !1, et = e; } } } function nc(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; et = e; } function Fo(e) { if (e !== et) return !1; if (!he) return nc(e), he = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !Cu(e.type, e.memoizedProps)), t && (t = qe)) { if (Pu(e)) throw fd(), Error(T(418)); for (; t;)cd(e, t), t = qt(t.nextSibling); } if (nc(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(T(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { qe = qt(e.nextSibling); break e; } t--; } else n !== "$" && n !== "$!" && n !== "$?" || t++; } e = e.nextSibling; } qe = null; } } else qe = et ? qt(e.stateNode.nextSibling) : null; return !0; } function fd() { for (var e = qe; e;)e = qt(e.nextSibling); } function rr() { qe = et = null, he = !1; } function Cs(e) { St === null ? St = [e] : St.push(e); } var zm = Ft.ReactCurrentBatchConfig; function yt(e, t) { if (e && e.defaultProps) { t = Se({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t; } return t; } var El = sn(null), Tl = null, Hn = null, Ls = null; function As() { Ls = Hn = Tl = null; } function xs(e) { var t = El.current; ae(El), e._currentValue = t; } function $u(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return; } } function Xn(e, t) { Tl = e, Ls = Hn = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (He = !0), e.firstContext = null); } function ft(e) { var t = e._currentValue; if (Ls !== e) if (e = { context: e, memoizedValue: t, next: null }, Hn === null) { if (Tl === null) throw Error(T(308)); Hn = e, Tl.dependencies = { lanes: 0, firstContext: e }; } else Hn = Hn.next = e; return t; } var yn = null; function Ps(e) { yn === null ? yn = [e] : yn.push(e); } function dd(e, t, n, r) { var o = t.interleaved; return o === null ? (n.next = n, Ps(t)) : (n.next = o.next, o.next = n), t.interleaved = n, Ut(e, r); } function Ut(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null; } var Ht = !1; function Ms(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null }; } function pd(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }); } function Vt(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null }; } function en(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, ee & 2) { var o = r.pending; return o === null ? t.next = t : (t.next = o.next, o.next = t), r.pending = t, Ut(e, n); } return o = r.interleaved, o === null ? (t.next = t, Ps(r)) : (t.next = o.next, o.next = t), r.interleaved = t, Ut(e, n); } function nl(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, ys(e, n); } } function rc(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var o = null, l = null; if (n = n.firstBaseUpdate, n !== null) { do { var i = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; l === null ? o = l = i : l = l.next = i, n = n.next; } while (n !== null); l === null ? o = l = t : l = l.next = t; } else o = l = t; n = { baseState: r.baseState, firstBaseUpdate: o, lastBaseUpdate: l, shared: r.shared, effects: r.effects }, e.updateQueue = n; return; } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t; } function kl(e, t, n, r) { var o = e.updateQueue; Ht = !1; var l = o.firstBaseUpdate, i = o.lastBaseUpdate, u = o.shared.pending; if (u !== null) { o.shared.pending = null; var s = u, a = s.next; s.next = null, i === null ? l = a : i.next = a, i = s; var f = e.alternate; f !== null && (f = f.updateQueue, u = f.lastBaseUpdate, u !== i && (u === null ? f.firstBaseUpdate = a : u.next = a, f.lastBaseUpdate = s)); } if (l !== null) { var p = o.baseState; i = 0, f = a = s = null, u = l; do { var m = u.lane, _ = u.eventTime; if ((r & m) === m) { f !== null && (f = f.next = { eventTime: _, lane: 0, tag: u.tag, payload: u.payload, callback: u.callback, next: null }); e: { var S = e, w = u; switch (m = t, _ = n, w.tag) { case 1: if (S = w.payload, typeof S == "function") { p = S.call(_, p, m); break e; } p = S; break e; case 3: S.flags = S.flags & -65537 | 128; case 0: if (S = w.payload, m = typeof S == "function" ? S.call(_, p, m) : S, m == null) break e; p = Se({}, p, m); break e; case 2: Ht = !0; } } u.callback !== null && u.lane !== 0 && (e.flags |= 64, m = o.effects, m === null ? o.effects = [u] : m.push(u)); } else _ = { eventTime: _, lane: m, tag: u.tag, payload: u.payload, callback: u.callback, next: null }, f === null ? (a = f = _, s = p) : f = f.next = _, i |= m; if (u = u.next, u === null) { if (u = o.shared.pending, u === null) break; m = u, u = m.next, m.next = null, o.lastBaseUpdate = m, o.shared.pending = null; } } while (!0); if (f === null && (s = p), o.baseState = s, o.firstBaseUpdate = a, o.lastBaseUpdate = f, t = o.shared.interleaved, t !== null) { o = t; do i |= o.lane, o = o.next; while (o !== t); } else l === null && (o.shared.lanes = 0); Tn |= i, e.lanes = i, e.memoizedState = p; } } function oc(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], o = r.callback; if (o !== null) { if (r.callback = null, r = n, typeof o != "function") throw Error(T(191, o)); o.call(r); } } } var hd = new df.Component().refs; function Iu(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : Se({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n); } var Kl = { isMounted: function (e) { return (e = e._reactInternals) ? An(e) === e : !1; }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = Oe(), o = nn(e), l = Vt(r, o); l.payload = t, n != null && (l.callback = n), t = en(e, l, o), t !== null && (wt(t, e, o, r), nl(t, e, o)); }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = Oe(), o = nn(e), l = Vt(r, o); l.tag = 1, l.payload = t, n != null && (l.callback = n), t = en(e, l, o), t !== null && (wt(t, e, o, r), nl(t, e, o)); }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = Oe(), r = nn(e), o = Vt(n, r); o.tag = 2, t != null && (o.callback = t), t = en(e, o, r), t !== null && (wt(t, e, r, n), nl(t, e, r)); } }; function lc(e, t, n, r, o, l, i) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, l, i) : t.prototype && t.prototype.isPureReactComponent ? !ro(n, r) || !ro(o, l) : !0; } function vd(e, t, n) { var r = !1, o = ln, l = t.contextType; return typeof l == "object" && l !== null ? l = ft(l) : (o = Ge(t) ? wn : ze.current, r = t.contextTypes, l = (r = r != null) ? nr(e, o) : ln), t = new t(n, l), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Kl, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = o, e.__reactInternalMemoizedMaskedChildContext = l), t; } function ic(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Kl.enqueueReplaceState(t, t.state, null); } function Vu(e, t, n, r) { var o = e.stateNode; o.props = n, o.state = e.memoizedState, o.refs = hd, Ms(e); var l = t.contextType; typeof l == "object" && l !== null ? o.context = ft(l) : (l = Ge(t) ? wn : ze.current, o.context = nr(e, l)), o.state = e.memoizedState, l = t.getDerivedStateFromProps, typeof l == "function" && (Iu(e, t, l, n), o.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof o.getSnapshotBeforeUpdate == "function" || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (t = o.state, typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount(), t !== o.state && Kl.enqueueReplaceState(o, o.state, null), kl(e, n, o, r), o.state = e.memoizedState), typeof o.componentDidMount == "function" && (e.flags |= 4194308); } function kr(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(T(309)); var r = n.stateNode; } if (!r) throw Error(T(147, e)); var o = r, l = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === l ? t.ref : (t = function (i) { var u = o.refs; u === hd && (u = o.refs = {}), i === null ? delete u[l] : u[l] = i; }, t._stringRef = l, t); } if (typeof e != "string") throw Error(T(284)); if (!n._owner) throw Error(T(290, e)); } return e; } function Bo(e, t) { throw e = Object.prototype.toString.call(t), Error(T(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)); } function uc(e) { var t = e._init; return t(e._payload); } function md(e) { function t(h, c) { if (e) { var d = h.deletions; d === null ? (h.deletions = [c], h.flags |= 16) : d.push(c); } } function n(h, c) { if (!e) return null; for (; c !== null;)t(h, c), c = c.sibling; return null; } function r(h, c) { for (h = new Map; c !== null;)c.key !== null ? h.set(c.key, c) : h.set(c.index, c), c = c.sibling; return h; } function o(h, c) { return h = rn(h, c), h.index = 0, h.sibling = null, h; } function l(h, c, d) { return h.index = d, e ? (d = h.alternate, d !== null ? (d = d.index, d < c ? (h.flags |= 2, c) : d) : (h.flags |= 2, c)) : (h.flags |= 1048576, c); } function i(h) { return e && h.alternate === null && (h.flags |= 2), h; } function u(h, c, d, R) { return c === null || c.tag !== 6 ? (c = Qi(d, h.mode, R), c.return = h, c) : (c = o(c, d), c.return = h, c); } function s(h, c, d, R) { var k = d.type; return k === Dn ? f(h, c, d.props.children, R, d.key) : c !== null && (c.elementType === k || typeof k == "object" && k !== null && k.$$typeof === Wt && uc(k) === c.type) ? (R = o(c, d.props), R.ref = kr(h, c, d), R.return = h, R) : (R = sl(d.type, d.key, d.props, null, h.mode, R), R.ref = kr(h, c, d), R.return = h, R); } function a(h, c, d, R) { return c === null || c.tag !== 4 || c.stateNode.containerInfo !== d.containerInfo || c.stateNode.implementation !== d.implementation ? (c = Yi(d, h.mode, R), c.return = h, c) : (c = o(c, d.children || []), c.return = h, c); } function f(h, c, d, R, k) { return c === null || c.tag !== 7 ? (c = _n(d, h.mode, R, k), c.return = h, c) : (c = o(c, d), c.return = h, c); } function p(h, c, d) { if (typeof c == "string" && c !== "" || typeof c == "number") return c = Qi("" + c, h.mode, d), c.return = h, c; if (typeof c == "object" && c !== null) { switch (c.$$typeof) { case xo: return d = sl(c.type, c.key, c.props, null, h.mode, d), d.ref = kr(h, null, c), d.return = h, d; case Vn: return c = Yi(c, h.mode, d), c.return = h, c; case Wt: var R = c._init; return p(h, R(c._payload), d); }if (Ir(c) || _r(c)) return c = _n(c, h.mode, d, null), c.return = h, c; Bo(h, c); } return null; } function m(h, c, d, R) { var k = c !== null ? c.key : null; if (typeof d == "string" && d !== "" || typeof d == "number") return k !== null ? null : u(h, c, "" + d, R); if (typeof d == "object" && d !== null) { switch (d.$$typeof) { case xo: return d.key === k ? s(h, c, d, R) : null; case Vn: return d.key === k ? a(h, c, d, R) : null; case Wt: return k = d._init, m(h, c, k(d._payload), R); }if (Ir(d) || _r(d)) return k !== null ? null : f(h, c, d, R, null); Bo(h, d); } return null; } function _(h, c, d, R, k) { if (typeof R == "string" && R !== "" || typeof R == "number") return h = h.get(d) || null, u(c, h, "" + R, k); if (typeof R == "object" && R !== null) { switch (R.$$typeof) { case xo: return h = h.get(R.key === null ? d : R.key) || null, s(c, h, R, k); case Vn: return h = h.get(R.key === null ? d : R.key) || null, a(c, h, R, k); case Wt: var C = R._init; return _(h, c, d, C(R._payload), k); }if (Ir(R) || _r(R)) return h = h.get(d) || null, f(c, h, R, k, null); Bo(c, R); } return null; } function S(h, c, d, R) { for (var k = null, C = null, L = c, I = c = 0, te = null; L !== null && I < d.length; I++) { L.index > I ? (te = L, L = null) : te = L.sibling; var U = m(h, L, d[I], R); if (U === null) { L === null && (L = te); break; } e && L && U.alternate === null && t(h, L), c = l(U, c, I), C === null ? k = U : C.sibling = U, C = U, L = te; } if (I === d.length) return n(h, L), he && pn(h, I), k; if (L === null) { for (; I < d.length; I++)L = p(h, d[I], R), L !== null && (c = l(L, c, I), C === null ? k = L : C.sibling = L, C = L); return he && pn(h, I), k; } for (L = r(h, L); I < d.length; I++)te = _(L, h, I, d[I], R), te !== null && (e && te.alternate !== null && L.delete(te.key === null ? I : te.key), c = l(te, c, I), C === null ? k = te : C.sibling = te, C = te); return e && L.forEach(function (fe) { return t(h, fe); }), he && pn(h, I), k; } function w(h, c, d, R) { var k = _r(d); if (typeof k != "function") throw Error(T(150)); if (d = k.call(d), d == null) throw Error(T(151)); for (var C = k = null, L = c, I = c = 0, te = null, U = d.next(); L !== null && !U.done; I++, U = d.next()) { L.index > I ? (te = L, L = null) : te = L.sibling; var fe = m(h, L, U.value, R); if (fe === null) { L === null && (L = te); break; } e && L && fe.alternate === null && t(h, L), c = l(fe, c, I), C === null ? k = fe : C.sibling = fe, C = fe, L = te; } if (U.done) return n(h, L), he && pn(h, I), k; if (L === null) { for (; !U.done; I++, U = d.next())U = p(h, U.value, R), U !== null && (c = l(U, c, I), C === null ? k = U : C.sibling = U, C = U); return he && pn(h, I), k; } for (L = r(h, L); !U.done; I++, U = d.next())U = _(L, h, I, U.value, R), U !== null && (e && U.alternate !== null && L.delete(U.key === null ? I : U.key), c = l(U, c, I), C === null ? k = U : C.sibling = U, C = U); return e && L.forEach(function (ot) { return t(h, ot); }), he && pn(h, I), k; } function B(h, c, d, R) { if (typeof d == "object" && d !== null && d.type === Dn && d.key === null && (d = d.props.children), typeof d == "object" && d !== null) { switch (d.$$typeof) { case xo: e: { for (var k = d.key, C = c; C !== null;) { if (C.key === k) { if (k = d.type, k === Dn) { if (C.tag === 7) { n(h, C.sibling), c = o(C, d.props.children), c.return = h, h = c; break e; } } else if (C.elementType === k || typeof k == "object" && k !== null && k.$$typeof === Wt && uc(k) === C.type) { n(h, C.sibling), c = o(C, d.props), c.ref = kr(h, C, d), c.return = h, h = c; break e; } n(h, C); break; } else t(h, C); C = C.sibling; } d.type === Dn ? (c = _n(d.props.children, h.mode, R, d.key), c.return = h, h = c) : (R = sl(d.type, d.key, d.props, null, h.mode, R), R.ref = kr(h, c, d), R.return = h, h = R); } return i(h); case Vn: e: { for (C = d.key; c !== null;) { if (c.key === C) if (c.tag === 4 && c.stateNode.containerInfo === d.containerInfo && c.stateNode.implementation === d.implementation) { n(h, c.sibling), c = o(c, d.children || []), c.return = h, h = c; break e; } else { n(h, c); break; } else t(h, c); c = c.sibling; } c = Yi(d, h.mode, R), c.return = h, h = c; } return i(h); case Wt: return C = d._init, B(h, c, C(d._payload), R); }if (Ir(d)) return S(h, c, d, R); if (_r(d)) return w(h, c, d, R); Bo(h, d); } return typeof d == "string" && d !== "" || typeof d == "number" ? (d = "" + d, c !== null && c.tag === 6 ? (n(h, c.sibling), c = o(c, d), c.return = h, h = c) : (n(h, c), c = Qi(d, h.mode, R), c.return = h, h = c), i(h)) : n(h, c); } return B; } var or = md(!0), yd = md(!1), go = {}, Ct = sn(go), uo = sn(go), so = sn(go); function gn(e) { if (e === go) throw Error(T(174)); return e; } function $s(e, t) { switch (ie(so, t), ie(uo, e), ie(Ct, go), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : pu(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = pu(t, e); }ae(Ct), ie(Ct, t); } function lr() { ae(Ct), ae(uo), ae(so); } function gd(e) { gn(so.current); var t = gn(Ct.current), n = pu(t, e.type); t !== n && (ie(uo, e), ie(Ct, n)); } function Is(e) { uo.current === e && (ae(Ct), ae(uo)); } var ye = sn(0); function Nl(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t; } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t; } else if (t.child !== null) { t.child.return = t, t = t.child; continue; } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return; } t.sibling.return = t.return, t = t.sibling; } return null; } var Bi = []; function Vs() { for (var e = 0; e < Bi.length; e++)Bi[e]._workInProgressVersionPrimary = null; Bi.length = 0; } var rl = Ft.ReactCurrentDispatcher, ji = Ft.ReactCurrentBatchConfig, En = 0, ge = null, Te = null, Ce = null, Cl = !1, Wr = !1, ao = 0, Um = 0; function Ie() { throw Error(T(321)); } function Ds(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!Rt(e[n], t[n])) return !1; return !0; } function zs(e, t, n, r, o, l) { if (En = l, ge = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, rl.current = e === null || e.memoizedState === null ? jm : Wm, e = n(r, o), Wr) { l = 0; do { if (Wr = !1, ao = 0, 25 <= l) throw Error(T(301)); l += 1, Ce = Te = null, t.updateQueue = null, rl.current = Hm, e = n(r, o); } while (Wr); } if (rl.current = Ll, t = Te !== null && Te.next !== null, En = 0, Ce = Te = ge = null, Cl = !1, t) throw Error(T(300)); return e; } function Us() { var e = ao !== 0; return ao = 0, e; } function Tt() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ce === null ? ge.memoizedState = Ce = e : Ce = Ce.next = e, Ce; } function dt() { if (Te === null) { var e = ge.alternate; e = e !== null ? e.memoizedState : null; } else e = Te.next; var t = Ce === null ? ge.memoizedState : Ce.next; if (t !== null) Ce = t, Te = e; else { if (e === null) throw Error(T(310)); Te = e, e = { memoizedState: Te.memoizedState, baseState: Te.baseState, baseQueue: Te.baseQueue, queue: Te.queue, next: null }, Ce === null ? ge.memoizedState = Ce = e : Ce = Ce.next = e; } return Ce; } function co(e, t) { return typeof t == "function" ? t(e) : t; } function Wi(e) { var t = dt(), n = t.queue; if (n === null) throw Error(T(311)); n.lastRenderedReducer = e; var r = Te, o = r.baseQueue, l = n.pending; if (l !== null) { if (o !== null) { var i = o.next; o.next = l.next, l.next = i; } r.baseQueue = o = l, n.pending = null; } if (o !== null) { l = o.next, r = r.baseState; var u = i = null, s = null, a = l; do { var f = a.lane; if ((En & f) === f) s !== null && (s = s.next = { lane: 0, action: a.action, hasEagerState: a.hasEagerState, eagerState: a.eagerState, next: null }), r = a.hasEagerState ? a.eagerState : e(r, a.action); else { var p = { lane: f, action: a.action, hasEagerState: a.hasEagerState, eagerState: a.eagerState, next: null }; s === null ? (u = s = p, i = r) : s = s.next = p, ge.lanes |= f, Tn |= f; } a = a.next; } while (a !== null && a !== l); s === null ? i = r : s.next = u, Rt(r, t.memoizedState) || (He = !0), t.memoizedState = r, t.baseState = i, t.baseQueue = s, n.lastRenderedState = r; } if (e = n.interleaved, e !== null) { o = e; do l = o.lane, ge.lanes |= l, Tn |= l, o = o.next; while (o !== e); } else o === null && (n.lanes = 0); return [t.memoizedState, n.dispatch]; } function Hi(e) { var t = dt(), n = t.queue; if (n === null) throw Error(T(311)); n.lastRenderedReducer = e; var r = n.dispatch, o = n.pending, l = t.memoizedState; if (o !== null) { n.pending = null; var i = o = o.next; do l = e(l, i.action), i = i.next; while (i !== o); Rt(l, t.memoizedState) || (He = !0), t.memoizedState = l, t.baseQueue === null && (t.baseState = l), n.lastRenderedState = l; } return [l, r]; } function Sd() { } function _d(e, t) { var n = ge, r = dt(), o = t(), l = !Rt(r.memoizedState, o); if (l && (r.memoizedState = o, He = !0), r = r.queue, Os(Ed.bind(null, n, r, e), [e]), r.getSnapshot !== t || l || Ce !== null && Ce.memoizedState.tag & 1) { if (n.flags |= 2048, fo(9, Rd.bind(null, n, r, o, t), void 0, null), Le === null) throw Error(T(349)); En & 30 || wd(n, t, o); } return o; } function wd(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = ge.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ge.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)); } function Rd(e, t, n, r) { t.value = n, t.getSnapshot = r, Td(t) && kd(e); } function Ed(e, t, n) { return n(function () { Td(t) && kd(e); }); } function Td(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Rt(e, n); } catch { return !0; } } function kd(e) { var t = Ut(e, 1); t !== null && wt(t, e, 1, -1); } function sc(e) { var t = Tt(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: co, lastRenderedState: e }, t.queue = e, e = e.dispatch = Bm.bind(null, ge, e), [t.memoizedState, e]; } function fo(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = ge.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ge.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e; } function Nd() { return dt().memoizedState; } function ol(e, t, n, r) { var o = Tt(); ge.flags |= e, o.memoizedState = fo(1 | t, n, void 0, r === void 0 ? null : r); } function Gl(e, t, n, r) { var o = dt(); r = r === void 0 ? null : r; var l = void 0; if (Te !== null) { var i = Te.memoizedState; if (l = i.destroy, r !== null && Ds(r, i.deps)) { o.memoizedState = fo(t, n, l, r); return; } } ge.flags |= e, o.memoizedState = fo(1 | t, n, l, r); } function ac(e, t) { return ol(8390656, 8, e, t); } function Os(e, t) { return Gl(2048, 8, e, t); } function Cd(e, t) { return Gl(4, 2, e, t); } function Ld(e, t) { return Gl(4, 4, e, t); } function Ad(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null); }; if (t != null) return e = e(), t.current = e, function () { t.current = null; }; } function xd(e, t, n) { return n = n != null ? n.concat([e]) : null, Gl(4, 4, Ad.bind(null, t, e), n); } function Fs() { } function Pd(e, t) { var n = dt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Ds(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e); } function Md(e, t) { var n = dt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Ds(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e); } function $d(e, t, n) { return En & 21 ? (Rt(n, t) || (n = Df(), ge.lanes |= n, Tn |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, He = !0), e.memoizedState = n); } function Om(e, t) { var n = ne; ne = n !== 0 && 4 > n ? n : 4, e(!0); var r = ji.transition; ji.transition = {}; try { e(!1), t(); } finally { ne = n, ji.transition = r; } } function Id() { return dt().memoizedState; } function Fm(e, t, n) { var r = nn(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Vd(e)) Dd(t, n); else if (n = dd(e, t, n, r), n !== null) { var o = Oe(); wt(n, e, r, o), zd(n, t, r); } } function Bm(e, t, n) { var r = nn(e), o = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Vd(e)) Dd(t, o); else { var l = e.alternate; if (e.lanes === 0 && (l === null || l.lanes === 0) && (l = t.lastRenderedReducer, l !== null)) try { var i = t.lastRenderedState, u = l(i, n); if (o.hasEagerState = !0, o.eagerState = u, Rt(u, i)) { var s = t.interleaved; s === null ? (o.next = o, Ps(t)) : (o.next = s.next, s.next = o), t.interleaved = o; return; } } catch { } finally { } n = dd(e, t, o, r), n !== null && (o = Oe(), wt(n, e, r, o), zd(n, t, r)); } } function Vd(e) { var t = e.alternate; return e === ge || t !== null && t === ge; } function Dd(e, t) { Wr = Cl = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t; } function zd(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, ys(e, n); } } var Ll = { readContext: ft, useCallback: Ie, useContext: Ie, useEffect: Ie, useImperativeHandle: Ie, useInsertionEffect: Ie, useLayoutEffect: Ie, useMemo: Ie, useReducer: Ie, useRef: Ie, useState: Ie, useDebugValue: Ie, useDeferredValue: Ie, useTransition: Ie, useMutableSource: Ie, useSyncExternalStore: Ie, useId: Ie, unstable_isNewReconciler: !1 }, jm = { readContext: ft, useCallback: function (e, t) { return Tt().memoizedState = [e, t === void 0 ? null : t], e; }, useContext: ft, useEffect: ac, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, ol(4194308, 4, Ad.bind(null, t, e), n); }, useLayoutEffect: function (e, t) { return ol(4194308, 4, e, t); }, useInsertionEffect: function (e, t) { return ol(4, 2, e, t); }, useMemo: function (e, t) { var n = Tt(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e; }, useReducer: function (e, t, n) { var r = Tt(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = Fm.bind(null, ge, e), [r.memoizedState, e]; }, useRef: function (e) { var t = Tt(); return e = { current: e }, t.memoizedState = e; }, useState: sc, useDebugValue: Fs, useDeferredValue: function (e) { return Tt().memoizedState = e; }, useTransition: function () { var e = sc(!1), t = e[0]; return e = Om.bind(null, e[1]), Tt().memoizedState = e, [t, e]; }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ge, o = Tt(); if (he) { if (n === void 0) throw Error(T(407)); n = n(); } else { if (n = t(), Le === null) throw Error(T(349)); En & 30 || wd(r, t, n); } o.memoizedState = n; var l = { value: n, getSnapshot: t }; return o.queue = l, ac(Ed.bind(null, r, l, e), [e]), r.flags |= 2048, fo(9, Rd.bind(null, r, l, n, t), void 0, null), n; }, useId: function () { var e = Tt(), t = Le.identifierPrefix; if (he) { var n = It, r = $t; n = (r & ~(1 << 32 - _t(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = ao++, 0 < n && (t += "H" + n.toString(32)), t += ":"; } else n = Um++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t; }, unstable_isNewReconciler: !1 }, Wm = { readContext: ft, useCallback: Pd, useContext: ft, useEffect: Os, useImperativeHandle: xd, useInsertionEffect: Cd, useLayoutEffect: Ld, useMemo: Md, useReducer: Wi, useRef: Nd, useState: function () { return Wi(co); }, useDebugValue: Fs, useDeferredValue: function (e) { var t = dt(); return $d(t, Te.memoizedState, e); }, useTransition: function () { var e = Wi(co)[0], t = dt().memoizedState; return [e, t]; }, useMutableSource: Sd, useSyncExternalStore: _d, useId: Id, unstable_isNewReconciler: !1 }, Hm = { readContext: ft, useCallback: Pd, useContext: ft, useEffect: Os, useImperativeHandle: xd, useInsertionEffect: Cd, useLayoutEffect: Ld, useMemo: Md, useReducer: Hi, useRef: Nd, useState: function () { return Hi(co); }, useDebugValue: Fs, useDeferredValue: function (e) { var t = dt(); return Te === null ? t.memoizedState = e : $d(t, Te.memoizedState, e); }, useTransition: function () { var e = Hi(co)[0], t = dt().memoizedState; return [e, t]; }, useMutableSource: Sd, useSyncExternalStore: _d, useId: Id, unstable_isNewReconciler: !1 }; function ir(e, t) {
    try { var n = "", r = t; do n += gv(r), r = r.return; while (r); var o = n; } catch (l) {
      o = `
Error generating stack: `+ l.message + `
`+ l.stack;
    } return { value: e, source: t, stack: o, digest: null };
  } function Ki(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null }; } function Du(e, t) { try { console.error(t.value); } catch (n) { setTimeout(function () { throw n; }); } } var Km = typeof WeakMap == "function" ? WeakMap : Map; function Ud(e, t, n) { n = Vt(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { xl || (xl = !0, Gu = r), Du(e, t); }, n; } function Od(e, t, n) { n = Vt(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var o = t.value; n.payload = function () { return r(o); }, n.callback = function () { Du(e, t); }; } var l = e.stateNode; return l !== null && typeof l.componentDidCatch == "function" && (n.callback = function () { Du(e, t), typeof r != "function" && (tn === null ? tn = new Set([this]) : tn.add(this)); var i = t.stack; this.componentDidCatch(t.value, { componentStack: i !== null ? i : "" }); }), n; } function cc(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new Km; var o = new Set; r.set(t, o); } else o = r.get(t), o === void 0 && (o = new Set, r.set(t, o)); o.has(n) || (o.add(n), e = ly.bind(null, e, t, n), t.then(e, e)); } function fc(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return; } while (e !== null); return null; } function dc(e, t, n, r, o) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = o, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Vt(-1, 1), t.tag = 2, en(n, t, 1))), n.lanes |= 1), e); } var Gm = Ft.ReactCurrentOwner, He = !1; function Ue(e, t, n, r) { t.child = e === null ? yd(t, null, n, r) : or(t, e.child, n, r); } function pc(e, t, n, r, o) { n = n.render; var l = t.ref; return Xn(t, o), r = zs(e, t, n, r, l, o), n = Us(), e !== null && !He ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~o, Ot(e, t, o)) : (he && n && ks(t), t.flags |= 1, Ue(e, t, r, o), t.child); } function hc(e, t, n, r, o) { if (e === null) { var l = n.type; return typeof l == "function" && !Ys(l) && l.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = l, Fd(e, t, l, r, o)) : (e = sl(n.type, null, r, t, t.mode, o), e.ref = t.ref, e.return = t, t.child = e); } if (l = e.child, !(e.lanes & o)) { var i = l.memoizedProps; if (n = n.compare, n = n !== null ? n : ro, n(i, r) && e.ref === t.ref) return Ot(e, t, o); } return t.flags |= 1, e = rn(l, r), e.ref = t.ref, e.return = t, t.child = e; } function Fd(e, t, n, r, o) { if (e !== null) { var l = e.memoizedProps; if (ro(l, r) && e.ref === t.ref) if (He = !1, t.pendingProps = r = l, (e.lanes & o) !== 0) e.flags & 131072 && (He = !0); else return t.lanes = e.lanes, Ot(e, t, o); } return zu(e, t, n, r, o); } function Bd(e, t, n) { var r = t.pendingProps, o = r.children, l = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ie(Gn, Je), Je |= n; else { if (!(n & 1073741824)) return e = l !== null ? l.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, ie(Gn, Je), Je |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = l !== null ? l.baseLanes : n, ie(Gn, Je), Je |= r; } else l !== null ? (r = l.baseLanes | n, t.memoizedState = null) : r = n, ie(Gn, Je), Je |= r; return Ue(e, t, o, n), t.child; } function jd(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152); } function zu(e, t, n, r, o) { var l = Ge(n) ? wn : ze.current; return l = nr(t, l), Xn(t, o), n = zs(e, t, n, r, l, o), r = Us(), e !== null && !He ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~o, Ot(e, t, o)) : (he && r && ks(t), t.flags |= 1, Ue(e, t, n, o), t.child); } function vc(e, t, n, r, o) { if (Ge(n)) { var l = !0; _l(t); } else l = !1; if (Xn(t, o), t.stateNode === null) ll(e, t), vd(t, n, r), Vu(t, n, r, o), r = !0; else if (e === null) { var i = t.stateNode, u = t.memoizedProps; i.props = u; var s = i.context, a = n.contextType; typeof a == "object" && a !== null ? a = ft(a) : (a = Ge(n) ? wn : ze.current, a = nr(t, a)); var f = n.getDerivedStateFromProps, p = typeof f == "function" || typeof i.getSnapshotBeforeUpdate == "function"; p || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (u !== r || s !== a) && ic(t, i, r, a), Ht = !1; var m = t.memoizedState; i.state = m, kl(t, r, i, o), s = t.memoizedState, u !== r || m !== s || Ke.current || Ht ? (typeof f == "function" && (Iu(t, n, f, r), s = t.memoizedState), (u = Ht || lc(t, n, u, r, m, s, a)) ? (p || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount()), typeof i.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof i.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = s), i.props = r, i.state = s, i.context = a, r = u) : (typeof i.componentDidMount == "function" && (t.flags |= 4194308), r = !1); } else { i = t.stateNode, pd(e, t), u = t.memoizedProps, a = t.type === t.elementType ? u : yt(t.type, u), i.props = a, p = t.pendingProps, m = i.context, s = n.contextType, typeof s == "object" && s !== null ? s = ft(s) : (s = Ge(n) ? wn : ze.current, s = nr(t, s)); var _ = n.getDerivedStateFromProps; (f = typeof _ == "function" || typeof i.getSnapshotBeforeUpdate == "function") || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (u !== p || m !== s) && ic(t, i, r, s), Ht = !1, m = t.memoizedState, i.state = m, kl(t, r, i, o); var S = t.memoizedState; u !== p || m !== S || Ke.current || Ht ? (typeof _ == "function" && (Iu(t, n, _, r), S = t.memoizedState), (a = Ht || lc(t, n, a, r, m, S, s) || !1) ? (f || typeof i.UNSAFE_componentWillUpdate != "function" && typeof i.componentWillUpdate != "function" || (typeof i.componentWillUpdate == "function" && i.componentWillUpdate(r, S, s), typeof i.UNSAFE_componentWillUpdate == "function" && i.UNSAFE_componentWillUpdate(r, S, s)), typeof i.componentDidUpdate == "function" && (t.flags |= 4), typeof i.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof i.componentDidUpdate != "function" || u === e.memoizedProps && m === e.memoizedState || (t.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || u === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = S), i.props = r, i.state = S, i.context = s, r = a) : (typeof i.componentDidUpdate != "function" || u === e.memoizedProps && m === e.memoizedState || (t.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || u === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024), r = !1); } return Uu(e, t, n, r, l, o); } function Uu(e, t, n, r, o, l) { jd(e, t); var i = (t.flags & 128) !== 0; if (!r && !i) return o && ec(t, n, !1), Ot(e, t, l); r = t.stateNode, Gm.current = t; var u = i && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && i ? (t.child = or(t, e.child, null, l), t.child = or(t, null, u, l)) : Ue(e, t, u, l), t.memoizedState = r.state, o && ec(t, n, !0), t.child; } function Wd(e) { var t = e.stateNode; t.pendingContext ? qa(e, t.pendingContext, t.pendingContext !== t.context) : t.context && qa(e, t.context, !1), $s(e, t.containerInfo); } function mc(e, t, n, r, o) { return rr(), Cs(o), t.flags |= 256, Ue(e, t, n, r), t.child; } var Ou = { dehydrated: null, treeContext: null, retryLane: 0 }; function Fu(e) { return { baseLanes: e, cachePool: null, transitions: null }; } function Hd(e, t, n) { var r = t.pendingProps, o = ye.current, l = !1, i = (t.flags & 128) !== 0, u; if ((u = i) || (u = e !== null && e.memoizedState === null ? !1 : (o & 2) !== 0), u ? (l = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (o |= 1), ie(ye, o & 1), e === null) return Mu(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (i = r.children, e = r.fallback, l ? (r = t.mode, l = t.child, i = { mode: "hidden", children: i }, !(r & 1) && l !== null ? (l.childLanes = 0, l.pendingProps = i) : l = Zl(i, r, 0, null), e = _n(e, r, n, null), l.return = t, e.return = t, l.sibling = e, t.child = l, t.child.memoizedState = Fu(n), t.memoizedState = Ou, e) : Bs(t, i)); if (o = e.memoizedState, o !== null && (u = o.dehydrated, u !== null)) return Qm(e, t, i, r, u, o, n); if (l) { l = r.fallback, i = t.mode, o = e.child, u = o.sibling; var s = { mode: "hidden", children: r.children }; return !(i & 1) && t.child !== o ? (r = t.child, r.childLanes = 0, r.pendingProps = s, t.deletions = null) : (r = rn(o, s), r.subtreeFlags = o.subtreeFlags & 14680064), u !== null ? l = rn(u, l) : (l = _n(l, i, n, null), l.flags |= 2), l.return = t, r.return = t, r.sibling = l, t.child = r, r = l, l = t.child, i = e.child.memoizedState, i = i === null ? Fu(n) : { baseLanes: i.baseLanes | n, cachePool: null, transitions: i.transitions }, l.memoizedState = i, l.childLanes = e.childLanes & ~n, t.memoizedState = Ou, r; } return l = e.child, e = l.sibling, r = rn(l, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r; } function Bs(e, t) { return t = Zl({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t; } function jo(e, t, n, r) { return r !== null && Cs(r), or(t, e.child, null, n), e = Bs(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e; } function Qm(e, t, n, r, o, l, i) { if (n) return t.flags & 256 ? (t.flags &= -257, r = Ki(Error(T(422))), jo(e, t, i, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (l = r.fallback, o = t.mode, r = Zl({ mode: "visible", children: r.children }, o, 0, null), l = _n(l, o, i, null), l.flags |= 2, r.return = t, l.return = t, r.sibling = l, t.child = r, t.mode & 1 && or(t, e.child, null, i), t.child.memoizedState = Fu(i), t.memoizedState = Ou, l); if (!(t.mode & 1)) return jo(e, t, i, null); if (o.data === "$!") { if (r = o.nextSibling && o.nextSibling.dataset, r) var u = r.dgst; return r = u, l = Error(T(419)), r = Ki(l, r, void 0), jo(e, t, i, r); } if (u = (i & e.childLanes) !== 0, He || u) { if (r = Le, r !== null) { switch (i & -i) { case 4: o = 2; break; case 16: o = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: o = 32; break; case 536870912: o = 268435456; break; default: o = 0; }o = o & (r.suspendedLanes | i) ? 0 : o, o !== 0 && o !== l.retryLane && (l.retryLane = o, Ut(e, o), wt(r, e, o, -1)); } return Qs(), r = Ki(Error(T(421))), jo(e, t, i, r); } return o.data === "$?" ? (t.flags |= 128, t.child = e.child, t = iy.bind(null, e), o._reactRetry = t, null) : (e = l.treeContext, qe = qt(o.nextSibling), et = t, he = !0, St = null, e !== null && (ut[st++] = $t, ut[st++] = It, ut[st++] = Rn, $t = e.id, It = e.overflow, Rn = t), t = Bs(t, r.children), t.flags |= 4096, t); } function yc(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), $u(e.return, t, n); } function Gi(e, t, n, r, o) { var l = e.memoizedState; l === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: o } : (l.isBackwards = t, l.rendering = null, l.renderingStartTime = 0, l.last = r, l.tail = n, l.tailMode = o); } function Kd(e, t, n) { var r = t.pendingProps, o = r.revealOrder, l = r.tail; if (Ue(e, t, r.children, n), r = ye.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && yc(e, n, t); else if (e.tag === 19) yc(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue; } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return; } e.sibling.return = e.return, e = e.sibling; } r &= 1; } if (ie(ye, r), !(t.mode & 1)) t.memoizedState = null; else switch (o) { case "forwards": for (n = t.child, o = null; n !== null;)e = n.alternate, e !== null && Nl(e) === null && (o = n), n = n.sibling; n = o, n === null ? (o = t.child, t.child = null) : (o = n.sibling, n.sibling = null), Gi(t, !1, o, n, l); break; case "backwards": for (n = null, o = t.child, t.child = null; o !== null;) { if (e = o.alternate, e !== null && Nl(e) === null) { t.child = o; break; } e = o.sibling, o.sibling = n, n = o, o = e; } Gi(t, !0, n, null, l); break; case "together": Gi(t, !1, null, null, void 0); break; default: t.memoizedState = null; }return t.child; } function ll(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2); } function Ot(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), Tn |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(T(153)); if (t.child !== null) { for (e = t.child, n = rn(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = rn(e, e.pendingProps), n.return = t; n.sibling = null; } return t.child; } function Ym(e, t, n) { switch (t.tag) { case 3: Wd(t), rr(); break; case 5: gd(t); break; case 1: Ge(t.type) && _l(t); break; case 4: $s(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, o = t.memoizedProps.value; ie(El, r._currentValue), r._currentValue = o; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (ie(ye, ye.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? Hd(e, t, n) : (ie(ye, ye.current & 1), e = Ot(e, t, n), e !== null ? e.sibling : null); ie(ye, ye.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return Kd(e, t, n); t.flags |= 128; } if (o = t.memoizedState, o !== null && (o.rendering = null, o.tail = null, o.lastEffect = null), ie(ye, ye.current), r) break; return null; case 22: case 23: return t.lanes = 0, Bd(e, t, n); }return Ot(e, t, n); } var Gd, Bu, Qd, Yd; Gd = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue; } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return; } n.sibling.return = n.return, n = n.sibling; } }; Bu = function () { }; Qd = function (e, t, n, r) { var o = e.memoizedProps; if (o !== r) { e = t.stateNode, gn(Ct.current); var l = null; switch (n) { case "input": o = au(e, o), r = au(e, r), l = []; break; case "select": o = Se({}, o, { value: void 0 }), r = Se({}, r, { value: void 0 }), l = []; break; case "textarea": o = du(e, o), r = du(e, r), l = []; break; default: typeof o.onClick != "function" && typeof r.onClick == "function" && (e.onclick = gl); }hu(n, r); var i; n = null; for (a in o) if (!r.hasOwnProperty(a) && o.hasOwnProperty(a) && o[a] != null) if (a === "style") { var u = o[a]; for (i in u) u.hasOwnProperty(i) && (n || (n = {}), n[i] = ""); } else a !== "dangerouslySetInnerHTML" && a !== "children" && a !== "suppressContentEditableWarning" && a !== "suppressHydrationWarning" && a !== "autoFocus" && (br.hasOwnProperty(a) ? l || (l = []) : (l = l || []).push(a, null)); for (a in r) { var s = r[a]; if (u = o != null ? o[a] : void 0, r.hasOwnProperty(a) && s !== u && (s != null || u != null)) if (a === "style") if (u) { for (i in u) !u.hasOwnProperty(i) || s && s.hasOwnProperty(i) || (n || (n = {}), n[i] = ""); for (i in s) s.hasOwnProperty(i) && u[i] !== s[i] && (n || (n = {}), n[i] = s[i]); } else n || (l || (l = []), l.push(a, n)), n = s; else a === "dangerouslySetInnerHTML" ? (s = s ? s.__html : void 0, u = u ? u.__html : void 0, s != null && u !== s && (l = l || []).push(a, s)) : a === "children" ? typeof s != "string" && typeof s != "number" || (l = l || []).push(a, "" + s) : a !== "suppressContentEditableWarning" && a !== "suppressHydrationWarning" && (br.hasOwnProperty(a) ? (s != null && a === "onScroll" && ue("scroll", e), l || u === s || (l = [])) : (l = l || []).push(a, s)); } n && (l = l || []).push("style", n); var a = l; (t.updateQueue = a) && (t.flags |= 4); } }; Yd = function (e, t, n, r) { n !== r && (t.flags |= 4); }; function Nr(e, t) { if (!he) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null; } } function Ve(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var o = e.child; o !== null;)n |= o.lanes | o.childLanes, r |= o.subtreeFlags & 14680064, r |= o.flags & 14680064, o.return = e, o = o.sibling; else for (o = e.child; o !== null;)n |= o.lanes | o.childLanes, r |= o.subtreeFlags, r |= o.flags, o.return = e, o = o.sibling; return e.subtreeFlags |= r, e.childLanes = n, t; } function Zm(e, t, n) { var r = t.pendingProps; switch (Ns(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ve(t), null; case 1: return Ge(t.type) && Sl(), Ve(t), null; case 3: return r = t.stateNode, lr(), ae(Ke), ae(ze), Vs(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (Fo(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, St !== null && (Zu(St), St = null))), Bu(e, t), Ve(t), null; case 5: Is(t); var o = gn(so.current); if (n = t.type, e !== null && t.stateNode != null) Qd(e, t, n, r, o), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(T(166)); return Ve(t), null; } if (e = gn(Ct.current), Fo(t)) { r = t.stateNode, n = t.type; var l = t.memoizedProps; switch (r[kt] = t, r[io] = l, e = (t.mode & 1) !== 0, n) { case "dialog": ue("cancel", r), ue("close", r); break; case "iframe": case "object": case "embed": ue("load", r); break; case "video": case "audio": for (o = 0; o < Dr.length; o++)ue(Dr[o], r); break; case "source": ue("error", r); break; case "img": case "image": case "link": ue("error", r), ue("load", r); break; case "details": ue("toggle", r); break; case "input": Na(r, l), ue("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!l.multiple }, ue("invalid", r); break; case "textarea": La(r, l), ue("invalid", r); }hu(n, l), o = null; for (var i in l) if (l.hasOwnProperty(i)) { var u = l[i]; i === "children" ? typeof u == "string" ? r.textContent !== u && (l.suppressHydrationWarning !== !0 && Oo(r.textContent, u, e), o = ["children", u]) : typeof u == "number" && r.textContent !== "" + u && (l.suppressHydrationWarning !== !0 && Oo(r.textContent, u, e), o = ["children", "" + u]) : br.hasOwnProperty(i) && u != null && i === "onScroll" && ue("scroll", r); } switch (n) { case "input": Po(r), Ca(r, l, !0); break; case "textarea": Po(r), Aa(r); break; case "select": case "option": break; default: typeof l.onClick == "function" && (r.onclick = gl); }r = o, t.updateQueue = r, r !== null && (t.flags |= 4); } else { i = o.nodeType === 9 ? o : o.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = wf(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = i.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = i.createElement(n, { is: r.is }) : (e = i.createElement(n), n === "select" && (i = e, r.multiple ? i.multiple = !0 : r.size && (i.size = r.size))) : e = i.createElementNS(e, n), e[kt] = t, e[io] = r, Gd(e, t, !1, !1), t.stateNode = e; e: { switch (i = vu(n, r), n) { case "dialog": ue("cancel", e), ue("close", e), o = r; break; case "iframe": case "object": case "embed": ue("load", e), o = r; break; case "video": case "audio": for (o = 0; o < Dr.length; o++)ue(Dr[o], e); o = r; break; case "source": ue("error", e), o = r; break; case "img": case "image": case "link": ue("error", e), ue("load", e), o = r; break; case "details": ue("toggle", e), o = r; break; case "input": Na(e, r), o = au(e, r), ue("invalid", e); break; case "option": o = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, o = Se({}, r, { value: void 0 }), ue("invalid", e); break; case "textarea": La(e, r), o = du(e, r), ue("invalid", e); break; default: o = r; }hu(n, o), u = o; for (l in u) if (u.hasOwnProperty(l)) { var s = u[l]; l === "style" ? Tf(e, s) : l === "dangerouslySetInnerHTML" ? (s = s ? s.__html : void 0, s != null && Rf(e, s)) : l === "children" ? typeof s == "string" ? (n !== "textarea" || s !== "") && Xr(e, s) : typeof s == "number" && Xr(e, "" + s) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (br.hasOwnProperty(l) ? s != null && l === "onScroll" && ue("scroll", e) : s != null && fs(e, l, s, i)); } switch (n) { case "input": Po(e), Ca(e, r, !1); break; case "textarea": Po(e), Aa(e); break; case "option": r.value != null && e.setAttribute("value", "" + on(r.value)); break; case "select": e.multiple = !!r.multiple, l = r.value, l != null ? Qn(e, !!r.multiple, l, !1) : r.defaultValue != null && Qn(e, !!r.multiple, r.defaultValue, !0); break; default: typeof o.onClick == "function" && (e.onclick = gl); }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1; } } r && (t.flags |= 4); } t.ref !== null && (t.flags |= 512, t.flags |= 2097152); } return Ve(t), null; case 6: if (e && t.stateNode != null) Yd(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(T(166)); if (n = gn(so.current), gn(Ct.current), Fo(t)) { if (r = t.stateNode, n = t.memoizedProps, r[kt] = t, (l = r.nodeValue !== n) && (e = et, e !== null)) switch (e.tag) { case 3: Oo(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && Oo(r.nodeValue, n, (e.mode & 1) !== 0); }l && (t.flags |= 4); } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[kt] = t, t.stateNode = r; } return Ve(t), null; case 13: if (ae(ye), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (he && qe !== null && t.mode & 1 && !(t.flags & 128)) fd(), rr(), t.flags |= 98560, l = !1; else if (l = Fo(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!l) throw Error(T(318)); if (l = t.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(T(317)); l[kt] = t; } else rr(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; Ve(t), l = !1; } else St !== null && (Zu(St), St = null), l = !0; if (!l) return t.flags & 65536 ? t : null; } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || ye.current & 1 ? ke === 0 && (ke = 3) : Qs())), t.updateQueue !== null && (t.flags |= 4), Ve(t), null); case 4: return lr(), Bu(e, t), e === null && oo(t.stateNode.containerInfo), Ve(t), null; case 10: return xs(t.type._context), Ve(t), null; case 17: return Ge(t.type) && Sl(), Ve(t), null; case 19: if (ae(ye), l = t.memoizedState, l === null) return Ve(t), null; if (r = (t.flags & 128) !== 0, i = l.rendering, i === null) if (r) Nr(l, !1); else { if (ke !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (i = Nl(e), i !== null) { for (t.flags |= 128, Nr(l, !1), r = i.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)l = n, e = r, l.flags &= 14680066, i = l.alternate, i === null ? (l.childLanes = 0, l.lanes = e, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null) : (l.childLanes = i.childLanes, l.lanes = i.lanes, l.child = i.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = i.memoizedProps, l.memoizedState = i.memoizedState, l.updateQueue = i.updateQueue, l.type = i.type, e = i.dependencies, l.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return ie(ye, ye.current & 1 | 2), t.child; } e = e.sibling; } l.tail !== null && we() > ur && (t.flags |= 128, r = !0, Nr(l, !1), t.lanes = 4194304); } else { if (!r) if (e = Nl(i), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), Nr(l, !0), l.tail === null && l.tailMode === "hidden" && !i.alternate && !he) return Ve(t), null; } else 2 * we() - l.renderingStartTime > ur && n !== 1073741824 && (t.flags |= 128, r = !0, Nr(l, !1), t.lanes = 4194304); l.isBackwards ? (i.sibling = t.child, t.child = i) : (n = l.last, n !== null ? n.sibling = i : t.child = i, l.last = i); } return l.tail !== null ? (t = l.tail, l.rendering = t, l.tail = t.sibling, l.renderingStartTime = we(), t.sibling = null, n = ye.current, ie(ye, r ? n & 1 | 2 : n & 1), t) : (Ve(t), null); case 22: case 23: return Gs(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Je & 1073741824 && (Ve(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Ve(t), null; case 24: return null; case 25: return null; }throw Error(T(156, t.tag)); } function bm(e, t) { switch (Ns(t), t.tag) { case 1: return Ge(t.type) && Sl(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return lr(), ae(Ke), ae(ze), Vs(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return Is(t), null; case 13: if (ae(ye), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(T(340)); rr(); } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return ae(ye), null; case 4: return lr(), null; case 10: return xs(t.type._context), null; case 22: case 23: return Gs(), null; case 24: return null; default: return null; } } var Wo = !1, De = !1, Xm = typeof WeakSet == "function" ? WeakSet : Set, D = null; function Kn(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null); } catch (r) { _e(e, t, r); } else n.current = null; } function ju(e, t, n) { try { n(); } catch (r) { _e(e, t, r); } } var gc = !1; function Jm(e, t) { if (ku = vl, e = Jf(), Ts(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var o = r.anchorOffset, l = r.focusNode; r = r.focusOffset; try { n.nodeType, l.nodeType; } catch { n = null; break e; } var i = 0, u = -1, s = -1, a = 0, f = 0, p = e, m = null; t: for (; ;) { for (var _; p !== n || o !== 0 && p.nodeType !== 3 || (u = i + o), p !== l || r !== 0 && p.nodeType !== 3 || (s = i + r), p.nodeType === 3 && (i += p.nodeValue.length), (_ = p.firstChild) !== null;)m = p, p = _; for (; ;) { if (p === e) break t; if (m === n && ++a === o && (u = i), m === l && ++f === r && (s = i), (_ = p.nextSibling) !== null) break; p = m, m = p.parentNode; } p = _; } n = u === -1 || s === -1 ? null : { start: u, end: s }; } else n = null; } n = n || { start: 0, end: 0 }; } else n = null; for (Nu = { focusedElem: e, selectionRange: n }, vl = !1, D = t; D !== null;)if (t = D, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, D = e; else for (; D !== null;) { t = D; try { var S = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (S !== null) { var w = S.memoizedProps, B = S.memoizedState, h = t.stateNode, c = h.getSnapshotBeforeUpdate(t.elementType === t.type ? w : yt(t.type, w), B); h.__reactInternalSnapshotBeforeUpdate = c; } break; case 3: var d = t.stateNode.containerInfo; d.nodeType === 1 ? d.textContent = "" : d.nodeType === 9 && d.documentElement && d.removeChild(d.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(T(163)); } } catch (R) { _e(t, t.return, R); } if (e = t.sibling, e !== null) { e.return = t.return, D = e; break; } D = t.return; } return S = gc, gc = !1, S; } function Hr(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var o = r = r.next; do { if ((o.tag & e) === e) { var l = o.destroy; o.destroy = void 0, l !== void 0 && ju(t, n, l); } o = o.next; } while (o !== r); } } function Ql(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r(); } n = n.next; } while (n !== t); } } function Wu(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n; }typeof t == "function" ? t(e) : t.current = e; } } function Zd(e) { var t = e.alternate; t !== null && (e.alternate = null, Zd(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[kt], delete t[io], delete t[Au], delete t[Im], delete t[Vm])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null; } function bd(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4; } function Sc(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || bd(e.return)) return null; e = e.return; } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child; } if (!(e.flags & 2)) return e.stateNode; } } function Hu(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = gl)); else if (r !== 4 && (e = e.child, e !== null)) for (Hu(e, t, n), e = e.sibling; e !== null;)Hu(e, t, n), e = e.sibling; } function Ku(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (Ku(e, t, n), e = e.sibling; e !== null;)Ku(e, t, n), e = e.sibling; } var Ae = null, gt = !1; function jt(e, t, n) { for (n = n.child; n !== null;)Xd(e, t, n), n = n.sibling; } function Xd(e, t, n) { if (Nt && typeof Nt.onCommitFiberUnmount == "function") try { Nt.onCommitFiberUnmount(Ol, n); } catch { } switch (n.tag) { case 5: De || Kn(n, t); case 6: var r = Ae, o = gt; Ae = null, jt(e, t, n), Ae = r, gt = o, Ae !== null && (gt ? (e = Ae, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Ae.removeChild(n.stateNode)); break; case 18: Ae !== null && (gt ? (e = Ae, n = n.stateNode, e.nodeType === 8 ? Oi(e.parentNode, n) : e.nodeType === 1 && Oi(e, n), to(e)) : Oi(Ae, n.stateNode)); break; case 4: r = Ae, o = gt, Ae = n.stateNode.containerInfo, gt = !0, jt(e, t, n), Ae = r, gt = o; break; case 0: case 11: case 14: case 15: if (!De && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { o = r = r.next; do { var l = o, i = l.destroy; l = l.tag, i !== void 0 && (l & 2 || l & 4) && ju(n, t, i), o = o.next; } while (o !== r); } jt(e, t, n); break; case 1: if (!De && (Kn(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount(); } catch (u) { _e(n, t, u); } jt(e, t, n); break; case 21: jt(e, t, n); break; case 22: n.mode & 1 ? (De = (r = De) || n.memoizedState !== null, jt(e, t, n), De = r) : jt(e, t, n); break; default: jt(e, t, n); } } function _c(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new Xm), t.forEach(function (r) { var o = uy.bind(null, e, r); n.has(r) || (n.add(r), r.then(o, o)); }); } } function vt(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var o = n[r]; try { var l = e, i = t, u = i; e: for (; u !== null;) { switch (u.tag) { case 5: Ae = u.stateNode, gt = !1; break e; case 3: Ae = u.stateNode.containerInfo, gt = !0; break e; case 4: Ae = u.stateNode.containerInfo, gt = !0; break e; }u = u.return; } if (Ae === null) throw Error(T(160)); Xd(l, i, o), Ae = null, gt = !1; var s = o.alternate; s !== null && (s.return = null), o.return = null; } catch (a) { _e(o, t, a); } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)Jd(t, e), t = t.sibling; } function Jd(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (vt(t, e), Et(e), r & 4) { try { Hr(3, e, e.return), Ql(3, e); } catch (w) { _e(e, e.return, w); } try { Hr(5, e, e.return); } catch (w) { _e(e, e.return, w); } } break; case 1: vt(t, e), Et(e), r & 512 && n !== null && Kn(n, n.return); break; case 5: if (vt(t, e), Et(e), r & 512 && n !== null && Kn(n, n.return), e.flags & 32) { var o = e.stateNode; try { Xr(o, ""); } catch (w) { _e(e, e.return, w); } } if (r & 4 && (o = e.stateNode, o != null)) { var l = e.memoizedProps, i = n !== null ? n.memoizedProps : l, u = e.type, s = e.updateQueue; if (e.updateQueue = null, s !== null) try { u === "input" && l.type === "radio" && l.name != null && Sf(o, l), vu(u, i); var a = vu(u, l); for (i = 0; i < s.length; i += 2) { var f = s[i], p = s[i + 1]; f === "style" ? Tf(o, p) : f === "dangerouslySetInnerHTML" ? Rf(o, p) : f === "children" ? Xr(o, p) : fs(o, f, p, a); } switch (u) { case "input": cu(o, l); break; case "textarea": _f(o, l); break; case "select": var m = o._wrapperState.wasMultiple; o._wrapperState.wasMultiple = !!l.multiple; var _ = l.value; _ != null ? Qn(o, !!l.multiple, _, !1) : m !== !!l.multiple && (l.defaultValue != null ? Qn(o, !!l.multiple, l.defaultValue, !0) : Qn(o, !!l.multiple, l.multiple ? [] : "", !1)); }o[io] = l; } catch (w) { _e(e, e.return, w); } } break; case 6: if (vt(t, e), Et(e), r & 4) { if (e.stateNode === null) throw Error(T(162)); o = e.stateNode, l = e.memoizedProps; try { o.nodeValue = l; } catch (w) { _e(e, e.return, w); } } break; case 3: if (vt(t, e), Et(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { to(t.containerInfo); } catch (w) { _e(e, e.return, w); } break; case 4: vt(t, e), Et(e); break; case 13: vt(t, e), Et(e), o = e.child, o.flags & 8192 && (l = o.memoizedState !== null, o.stateNode.isHidden = l, !l || o.alternate !== null && o.alternate.memoizedState !== null || (Hs = we())), r & 4 && _c(e); break; case 22: if (f = n !== null && n.memoizedState !== null, e.mode & 1 ? (De = (a = De) || f, vt(t, e), De = a) : vt(t, e), Et(e), r & 8192) { if (a = e.memoizedState !== null, (e.stateNode.isHidden = a) && !f && e.mode & 1) for (D = e, f = e.child; f !== null;) { for (p = D = f; D !== null;) { switch (m = D, _ = m.child, m.tag) { case 0: case 11: case 14: case 15: Hr(4, m, m.return); break; case 1: Kn(m, m.return); var S = m.stateNode; if (typeof S.componentWillUnmount == "function") { r = m, n = m.return; try { t = r, S.props = t.memoizedProps, S.state = t.memoizedState, S.componentWillUnmount(); } catch (w) { _e(r, n, w); } } break; case 5: Kn(m, m.return); break; case 22: if (m.memoizedState !== null) { Rc(p); continue; } }_ !== null ? (_.return = m, D = _) : Rc(p); } f = f.sibling; } e: for (f = null, p = e; ;) { if (p.tag === 5) { if (f === null) { f = p; try { o = p.stateNode, a ? (l = o.style, typeof l.setProperty == "function" ? l.setProperty("display", "none", "important") : l.display = "none") : (u = p.stateNode, s = p.memoizedProps.style, i = s != null && s.hasOwnProperty("display") ? s.display : null, u.style.display = Ef("display", i)); } catch (w) { _e(e, e.return, w); } } } else if (p.tag === 6) { if (f === null) try { p.stateNode.nodeValue = a ? "" : p.memoizedProps; } catch (w) { _e(e, e.return, w); } } else if ((p.tag !== 22 && p.tag !== 23 || p.memoizedState === null || p === e) && p.child !== null) { p.child.return = p, p = p.child; continue; } if (p === e) break e; for (; p.sibling === null;) { if (p.return === null || p.return === e) break e; f === p && (f = null), p = p.return; } f === p && (f = null), p.sibling.return = p.return, p = p.sibling; } } break; case 19: vt(t, e), Et(e), r & 4 && _c(e); break; case 21: break; default: vt(t, e), Et(e); } } function Et(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (bd(n)) { var r = n; break e; } n = n.return; } throw Error(T(160)); } switch (r.tag) { case 5: var o = r.stateNode; r.flags & 32 && (Xr(o, ""), r.flags &= -33); var l = Sc(e); Ku(e, l, o); break; case 3: case 4: var i = r.stateNode.containerInfo, u = Sc(e); Hu(e, u, i); break; default: throw Error(T(161)); } } catch (s) { _e(e, e.return, s); } e.flags &= -3; } t & 4096 && (e.flags &= -4097); } function qm(e, t, n) { D = e, qd(e); } function qd(e, t, n) { for (var r = (e.mode & 1) !== 0; D !== null;) { var o = D, l = o.child; if (o.tag === 22 && r) { var i = o.memoizedState !== null || Wo; if (!i) { var u = o.alternate, s = u !== null && u.memoizedState !== null || De; u = Wo; var a = De; if (Wo = i, (De = s) && !a) for (D = o; D !== null;)i = D, s = i.child, i.tag === 22 && i.memoizedState !== null ? Ec(o) : s !== null ? (s.return = i, D = s) : Ec(o); for (; l !== null;)D = l, qd(l), l = l.sibling; D = o, Wo = u, De = a; } wc(e); } else o.subtreeFlags & 8772 && l !== null ? (l.return = o, D = l) : wc(e); } } function wc(e) { for (; D !== null;) { var t = D; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: De || Ql(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !De) if (n === null) r.componentDidMount(); else { var o = t.elementType === t.type ? n.memoizedProps : yt(t.type, n.memoizedProps); r.componentDidUpdate(o, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate); } var l = t.updateQueue; l !== null && oc(t, l, r); break; case 3: var i = t.updateQueue; if (i !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode; }oc(t, i, n); } break; case 5: var u = t.stateNode; if (n === null && t.flags & 4) { n = u; var s = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": s.autoFocus && n.focus(); break; case "img": s.src && (n.src = s.src); } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var a = t.alternate; if (a !== null) { var f = a.memoizedState; if (f !== null) { var p = f.dehydrated; p !== null && to(p); } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(T(163)); }De || t.flags & 512 && Wu(t); } catch (m) { _e(t, t.return, m); } } if (t === e) { D = null; break; } if (n = t.sibling, n !== null) { n.return = t.return, D = n; break; } D = t.return; } } function Rc(e) { for (; D !== null;) { var t = D; if (t === e) { D = null; break; } var n = t.sibling; if (n !== null) { n.return = t.return, D = n; break; } D = t.return; } } function Ec(e) { for (; D !== null;) { var t = D; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { Ql(4, t); } catch (s) { _e(t, n, s); } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var o = t.return; try { r.componentDidMount(); } catch (s) { _e(t, o, s); } } var l = t.return; try { Wu(t); } catch (s) { _e(t, l, s); } break; case 5: var i = t.return; try { Wu(t); } catch (s) { _e(t, i, s); } } } catch (s) { _e(t, t.return, s); } if (t === e) { D = null; break; } var u = t.sibling; if (u !== null) { u.return = t.return, D = u; break; } D = t.return; } } var ey = Math.ceil, Al = Ft.ReactCurrentDispatcher, js = Ft.ReactCurrentOwner, ct = Ft.ReactCurrentBatchConfig, ee = 0, Le = null, Re = null, xe = 0, Je = 0, Gn = sn(0), ke = 0, po = null, Tn = 0, Yl = 0, Ws = 0, Kr = null, We = null, Hs = 0, ur = 1 / 0, Pt = null, xl = !1, Gu = null, tn = null, Ho = !1, Zt = null, Pl = 0, Gr = 0, Qu = null, il = -1, ul = 0; function Oe() { return ee & 6 ? we() : il !== -1 ? il : il = we(); } function nn(e) { return e.mode & 1 ? ee & 2 && xe !== 0 ? xe & -xe : zm.transition !== null ? (ul === 0 && (ul = Df()), ul) : (e = ne, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Wf(e.type)), e) : 1; } function wt(e, t, n, r) { if (50 < Gr) throw Gr = 0, Qu = null, Error(T(185)); vo(e, n, r), (!(ee & 2) || e !== Le) && (e === Le && (!(ee & 2) && (Yl |= n), ke === 4 && Qt(e, xe)), Qe(e, r), n === 1 && ee === 0 && !(t.mode & 1) && (ur = we() + 500, Hl && an())); } function Qe(e, t) { var n = e.callbackNode; zv(e, t); var r = hl(e, e === Le ? xe : 0); if (r === 0) n !== null && Ma(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && Ma(n), t === 1) e.tag === 0 ? Dm(Tc.bind(null, e)) : sd(Tc.bind(null, e)), Mm(function () { !(ee & 6) && an(); }), n = null; else { switch (zf(r)) { case 1: n = ms; break; case 4: n = If; break; case 16: n = pl; break; case 536870912: n = Vf; break; default: n = pl; }n = up(n, ep.bind(null, e)); } e.callbackPriority = t, e.callbackNode = n; } } function ep(e, t) { if (il = -1, ul = 0, ee & 6) throw Error(T(327)); var n = e.callbackNode; if (Jn() && e.callbackNode !== n) return null; var r = hl(e, e === Le ? xe : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = Ml(e, r); else { t = r; var o = ee; ee |= 2; var l = np(); (Le !== e || xe !== t) && (Pt = null, ur = we() + 500, Sn(e, t)); do try { ry(); break; } catch (u) { tp(e, u); } while (!0); As(), Al.current = l, ee = o, Re !== null ? t = 0 : (Le = null, xe = 0, t = ke); } if (t !== 0) { if (t === 2 && (o = _u(e), o !== 0 && (r = o, t = Yu(e, o))), t === 1) throw n = po, Sn(e, 0), Qt(e, r), Qe(e, we()), n; if (t === 6) Qt(e, r); else { if (o = e.current.alternate, !(r & 30) && !ty(o) && (t = Ml(e, r), t === 2 && (l = _u(e), l !== 0 && (r = l, t = Yu(e, l))), t === 1)) throw n = po, Sn(e, 0), Qt(e, r), Qe(e, we()), n; switch (e.finishedWork = o, e.finishedLanes = r, t) { case 0: case 1: throw Error(T(345)); case 2: hn(e, We, Pt); break; case 3: if (Qt(e, r), (r & 130023424) === r && (t = Hs + 500 - we(), 10 < t)) { if (hl(e, 0) !== 0) break; if (o = e.suspendedLanes, (o & r) !== r) { Oe(), e.pingedLanes |= e.suspendedLanes & o; break; } e.timeoutHandle = Lu(hn.bind(null, e, We, Pt), t); break; } hn(e, We, Pt); break; case 4: if (Qt(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, o = -1; 0 < r;) { var i = 31 - _t(r); l = 1 << i, i = t[i], i > o && (o = i), r &= ~l; } if (r = o, r = we() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * ey(r / 1960)) - r, 10 < r) { e.timeoutHandle = Lu(hn.bind(null, e, We, Pt), r); break; } hn(e, We, Pt); break; case 5: hn(e, We, Pt); break; default: throw Error(T(329)); } } } return Qe(e, we()), e.callbackNode === n ? ep.bind(null, e) : null; } function Yu(e, t) { var n = Kr; return e.current.memoizedState.isDehydrated && (Sn(e, t).flags |= 256), e = Ml(e, t), e !== 2 && (t = We, We = n, t !== null && Zu(t)), e; } function Zu(e) { We === null ? We = e : We.push.apply(We, e); } function ty(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var o = n[r], l = o.getSnapshot; o = o.value; try { if (!Rt(l(), o)) return !1; } catch { return !1; } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return; } t.sibling.return = t.return, t = t.sibling; } } return !0; } function Qt(e, t) { for (t &= ~Ws, t &= ~Yl, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - _t(t), r = 1 << n; e[n] = -1, t &= ~r; } } function Tc(e) { if (ee & 6) throw Error(T(327)); Jn(); var t = hl(e, 0); if (!(t & 1)) return Qe(e, we()), null; var n = Ml(e, t); if (e.tag !== 0 && n === 2) { var r = _u(e); r !== 0 && (t = r, n = Yu(e, r)); } if (n === 1) throw n = po, Sn(e, 0), Qt(e, t), Qe(e, we()), n; if (n === 6) throw Error(T(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, hn(e, We, Pt), Qe(e, we()), null; } function Ks(e, t) { var n = ee; ee |= 1; try { return e(t); } finally { ee = n, ee === 0 && (ur = we() + 500, Hl && an()); } } function kn(e) { Zt !== null && Zt.tag === 0 && !(ee & 6) && Jn(); var t = ee; ee |= 1; var n = ct.transition, r = ne; try { if (ct.transition = null, ne = 1, e) return e(); } finally { ne = r, ct.transition = n, ee = t, !(ee & 6) && an(); } } function Gs() { Je = Gn.current, ae(Gn); } function Sn(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, Pm(n)), Re !== null) for (n = Re.return; n !== null;) { var r = n; switch (Ns(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Sl(); break; case 3: lr(), ae(Ke), ae(ze), Vs(); break; case 5: Is(r); break; case 4: lr(); break; case 13: ae(ye); break; case 19: ae(ye); break; case 10: xs(r.type._context); break; case 22: case 23: Gs(); }n = n.return; } if (Le = e, Re = e = rn(e.current, null), xe = Je = t, ke = 0, po = null, Ws = Yl = Tn = 0, We = Kr = null, yn !== null) { for (t = 0; t < yn.length; t++)if (n = yn[t], r = n.interleaved, r !== null) { n.interleaved = null; var o = r.next, l = n.pending; if (l !== null) { var i = l.next; l.next = o, r.next = i; } n.pending = r; } yn = null; } return e; } function tp(e, t) { do { var n = Re; try { if (As(), rl.current = Ll, Cl) { for (var r = ge.memoizedState; r !== null;) { var o = r.queue; o !== null && (o.pending = null), r = r.next; } Cl = !1; } if (En = 0, Ce = Te = ge = null, Wr = !1, ao = 0, js.current = null, n === null || n.return === null) { ke = 1, po = t, Re = null; break; } e: { var l = e, i = n.return, u = n, s = t; if (t = xe, u.flags |= 32768, s !== null && typeof s == "object" && typeof s.then == "function") { var a = s, f = u, p = f.tag; if (!(f.mode & 1) && (p === 0 || p === 11 || p === 15)) { var m = f.alternate; m ? (f.updateQueue = m.updateQueue, f.memoizedState = m.memoizedState, f.lanes = m.lanes) : (f.updateQueue = null, f.memoizedState = null); } var _ = fc(i); if (_ !== null) { _.flags &= -257, dc(_, i, u, l, t), _.mode & 1 && cc(l, a, t), t = _, s = a; var S = t.updateQueue; if (S === null) { var w = new Set; w.add(s), t.updateQueue = w; } else S.add(s); break e; } else { if (!(t & 1)) { cc(l, a, t), Qs(); break e; } s = Error(T(426)); } } else if (he && u.mode & 1) { var B = fc(i); if (B !== null) { !(B.flags & 65536) && (B.flags |= 256), dc(B, i, u, l, t), Cs(ir(s, u)); break e; } } l = s = ir(s, u), ke !== 4 && (ke = 2), Kr === null ? Kr = [l] : Kr.push(l), l = i; do { switch (l.tag) { case 3: l.flags |= 65536, t &= -t, l.lanes |= t; var h = Ud(l, s, t); rc(l, h); break e; case 1: u = s; var c = l.type, d = l.stateNode; if (!(l.flags & 128) && (typeof c.getDerivedStateFromError == "function" || d !== null && typeof d.componentDidCatch == "function" && (tn === null || !tn.has(d)))) { l.flags |= 65536, t &= -t, l.lanes |= t; var R = Od(l, u, t); rc(l, R); break e; } }l = l.return; } while (l !== null); } op(n); } catch (k) { t = k, Re === n && n !== null && (Re = n = n.return); continue; } break; } while (!0); } function np() { var e = Al.current; return Al.current = Ll, e === null ? Ll : e; } function Qs() { (ke === 0 || ke === 3 || ke === 2) && (ke = 4), Le === null || !(Tn & 268435455) && !(Yl & 268435455) || Qt(Le, xe); } function Ml(e, t) { var n = ee; ee |= 2; var r = np(); (Le !== e || xe !== t) && (Pt = null, Sn(e, t)); do try { ny(); break; } catch (o) { tp(e, o); } while (!0); if (As(), ee = n, Al.current = r, Re !== null) throw Error(T(261)); return Le = null, xe = 0, ke; } function ny() { for (; Re !== null;)rp(Re); } function ry() { for (; Re !== null && !Lv();)rp(Re); } function rp(e) { var t = ip(e.alternate, e, Je); e.memoizedProps = e.pendingProps, t === null ? op(e) : Re = t, js.current = null; } function op(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = bm(n, t), n !== null) { n.flags &= 32767, Re = n; return; } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { ke = 6, Re = null; return; } } else if (n = Zm(n, t, Je), n !== null) { Re = n; return; } if (t = t.sibling, t !== null) { Re = t; return; } Re = t = e; } while (t !== null); ke === 0 && (ke = 5); } function hn(e, t, n) { var r = ne, o = ct.transition; try { ct.transition = null, ne = 1, oy(e, t, n, r); } finally { ct.transition = o, ne = r; } return null; } function oy(e, t, n, r) { do Jn(); while (Zt !== null); if (ee & 6) throw Error(T(327)); n = e.finishedWork; var o = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(T(177)); e.callbackNode = null, e.callbackPriority = 0; var l = n.lanes | n.childLanes; if (Uv(e, l), e === Le && (Re = Le = null, xe = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Ho || (Ho = !0, up(pl, function () { return Jn(), null; })), l = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || l) { l = ct.transition, ct.transition = null; var i = ne; ne = 1; var u = ee; ee |= 4, js.current = null, Jm(e, n), Jd(n, e), Tm(Nu), vl = !!ku, Nu = ku = null, e.current = n, qm(n), Av(), ee = u, ne = i, ct.transition = l; } else e.current = n; if (Ho && (Ho = !1, Zt = e, Pl = o), l = e.pendingLanes, l === 0 && (tn = null), Mv(n.stateNode), Qe(e, we()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)o = t[n], r(o.value, { componentStack: o.stack, digest: o.digest }); if (xl) throw xl = !1, e = Gu, Gu = null, e; return Pl & 1 && e.tag !== 0 && Jn(), l = e.pendingLanes, l & 1 ? e === Qu ? Gr++ : (Gr = 0, Qu = e) : Gr = 0, an(), null; } function Jn() { if (Zt !== null) { var e = zf(Pl), t = ct.transition, n = ne; try { if (ct.transition = null, ne = 16 > e ? 16 : e, Zt === null) var r = !1; else { if (e = Zt, Zt = null, Pl = 0, ee & 6) throw Error(T(331)); var o = ee; for (ee |= 4, D = e.current; D !== null;) { var l = D, i = l.child; if (D.flags & 16) { var u = l.deletions; if (u !== null) { for (var s = 0; s < u.length; s++) { var a = u[s]; for (D = a; D !== null;) { var f = D; switch (f.tag) { case 0: case 11: case 15: Hr(8, f, l); }var p = f.child; if (p !== null) p.return = f, D = p; else for (; D !== null;) { f = D; var m = f.sibling, _ = f.return; if (Zd(f), f === a) { D = null; break; } if (m !== null) { m.return = _, D = m; break; } D = _; } } } var S = l.alternate; if (S !== null) { var w = S.child; if (w !== null) { S.child = null; do { var B = w.sibling; w.sibling = null, w = B; } while (w !== null); } } D = l; } } if (l.subtreeFlags & 2064 && i !== null) i.return = l, D = i; else e: for (; D !== null;) { if (l = D, l.flags & 2048) switch (l.tag) { case 0: case 11: case 15: Hr(9, l, l.return); }var h = l.sibling; if (h !== null) { h.return = l.return, D = h; break e; } D = l.return; } } var c = e.current; for (D = c; D !== null;) { i = D; var d = i.child; if (i.subtreeFlags & 2064 && d !== null) d.return = i, D = d; else e: for (i = c; D !== null;) { if (u = D, u.flags & 2048) try { switch (u.tag) { case 0: case 11: case 15: Ql(9, u); } } catch (k) { _e(u, u.return, k); } if (u === i) { D = null; break e; } var R = u.sibling; if (R !== null) { R.return = u.return, D = R; break e; } D = u.return; } } if (ee = o, an(), Nt && typeof Nt.onPostCommitFiberRoot == "function") try { Nt.onPostCommitFiberRoot(Ol, e); } catch { } r = !0; } return r; } finally { ne = n, ct.transition = t; } } return !1; } function kc(e, t, n) { t = ir(n, t), t = Ud(e, t, 1), e = en(e, t, 1), t = Oe(), e !== null && (vo(e, 1, t), Qe(e, t)); } function _e(e, t, n) { if (e.tag === 3) kc(e, e, n); else for (; t !== null;) { if (t.tag === 3) { kc(t, e, n); break; } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (tn === null || !tn.has(r))) { e = ir(n, e), e = Od(t, e, 1), t = en(t, e, 1), e = Oe(), t !== null && (vo(t, 1, e), Qe(t, e)); break; } } t = t.return; } } function ly(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = Oe(), e.pingedLanes |= e.suspendedLanes & n, Le === e && (xe & n) === n && (ke === 4 || ke === 3 && (xe & 130023424) === xe && 500 > we() - Hs ? Sn(e, 0) : Ws |= n), Qe(e, t); } function lp(e, t) { t === 0 && (e.mode & 1 ? (t = Io, Io <<= 1, !(Io & 130023424) && (Io = 4194304)) : t = 1); var n = Oe(); e = Ut(e, t), e !== null && (vo(e, t, n), Qe(e, n)); } function iy(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), lp(e, n); } function uy(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, o = e.memoizedState; o !== null && (n = o.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(T(314)); }r !== null && r.delete(t), lp(e, n); } var ip; ip = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || Ke.current) He = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return He = !1, Ym(e, t, n); He = !!(e.flags & 131072); } else He = !1, he && t.flags & 1048576 && ad(t, Rl, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; ll(e, t), e = t.pendingProps; var o = nr(t, ze.current); Xn(t, n), o = zs(null, t, r, e, o, n); var l = Us(); return t.flags |= 1, typeof o == "object" && o !== null && typeof o.render == "function" && o.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ge(r) ? (l = !0, _l(t)) : l = !1, t.memoizedState = o.state !== null && o.state !== void 0 ? o.state : null, Ms(t), o.updater = Kl, t.stateNode = o, o._reactInternals = t, Vu(t, r, e, n), t = Uu(null, t, r, !0, l, n)) : (t.tag = 0, he && l && ks(t), Ue(null, t, o, n), t = t.child), t; case 16: r = t.elementType; e: { switch (ll(e, t), e = t.pendingProps, o = r._init, r = o(r._payload), t.type = r, o = t.tag = ay(r), e = yt(r, e), o) { case 0: t = zu(null, t, r, e, n); break e; case 1: t = vc(null, t, r, e, n); break e; case 11: t = pc(null, t, r, e, n); break e; case 14: t = hc(null, t, r, yt(r.type, e), n); break e; }throw Error(T(306, r, "")); } return t; case 0: return r = t.type, o = t.pendingProps, o = t.elementType === r ? o : yt(r, o), zu(e, t, r, o, n); case 1: return r = t.type, o = t.pendingProps, o = t.elementType === r ? o : yt(r, o), vc(e, t, r, o, n); case 3: e: { if (Wd(t), e === null) throw Error(T(387)); r = t.pendingProps, l = t.memoizedState, o = l.element, pd(e, t), kl(t, r, null, n); var i = t.memoizedState; if (r = i.element, l.isDehydrated) if (l = { element: r, isDehydrated: !1, cache: i.cache, pendingSuspenseBoundaries: i.pendingSuspenseBoundaries, transitions: i.transitions }, t.updateQueue.baseState = l, t.memoizedState = l, t.flags & 256) { o = ir(Error(T(423)), t), t = mc(e, t, r, n, o); break e; } else if (r !== o) { o = ir(Error(T(424)), t), t = mc(e, t, r, n, o); break e; } else for (qe = qt(t.stateNode.containerInfo.firstChild), et = t, he = !0, St = null, n = yd(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (rr(), r === o) { t = Ot(e, t, n); break e; } Ue(e, t, r, n); } t = t.child; } return t; case 5: return gd(t), e === null && Mu(t), r = t.type, o = t.pendingProps, l = e !== null ? e.memoizedProps : null, i = o.children, Cu(r, o) ? i = null : l !== null && Cu(r, l) && (t.flags |= 32), jd(e, t), Ue(e, t, i, n), t.child; case 6: return e === null && Mu(t), null; case 13: return Hd(e, t, n); case 4: return $s(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = or(t, null, r, n) : Ue(e, t, r, n), t.child; case 11: return r = t.type, o = t.pendingProps, o = t.elementType === r ? o : yt(r, o), pc(e, t, r, o, n); case 7: return Ue(e, t, t.pendingProps, n), t.child; case 8: return Ue(e, t, t.pendingProps.children, n), t.child; case 12: return Ue(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, o = t.pendingProps, l = t.memoizedProps, i = o.value, ie(El, r._currentValue), r._currentValue = i, l !== null) if (Rt(l.value, i)) { if (l.children === o.children && !Ke.current) { t = Ot(e, t, n); break e; } } else for (l = t.child, l !== null && (l.return = t); l !== null;) { var u = l.dependencies; if (u !== null) { i = l.child; for (var s = u.firstContext; s !== null;) { if (s.context === r) { if (l.tag === 1) { s = Vt(-1, n & -n), s.tag = 2; var a = l.updateQueue; if (a !== null) { a = a.shared; var f = a.pending; f === null ? s.next = s : (s.next = f.next, f.next = s), a.pending = s; } } l.lanes |= n, s = l.alternate, s !== null && (s.lanes |= n), $u(l.return, n, t), u.lanes |= n; break; } s = s.next; } } else if (l.tag === 10) i = l.type === t.type ? null : l.child; else if (l.tag === 18) { if (i = l.return, i === null) throw Error(T(341)); i.lanes |= n, u = i.alternate, u !== null && (u.lanes |= n), $u(i, n, t), i = l.sibling; } else i = l.child; if (i !== null) i.return = l; else for (i = l; i !== null;) { if (i === t) { i = null; break; } if (l = i.sibling, l !== null) { l.return = i.return, i = l; break; } i = i.return; } l = i; } Ue(e, t, o.children, n), t = t.child; } return t; case 9: return o = t.type, r = t.pendingProps.children, Xn(t, n), o = ft(o), r = r(o), t.flags |= 1, Ue(e, t, r, n), t.child; case 14: return r = t.type, o = yt(r, t.pendingProps), o = yt(r.type, o), hc(e, t, r, o, n); case 15: return Fd(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, o = t.pendingProps, o = t.elementType === r ? o : yt(r, o), ll(e, t), t.tag = 1, Ge(r) ? (e = !0, _l(t)) : e = !1, Xn(t, n), vd(t, r, o), Vu(t, r, o, n), Uu(null, t, r, !0, e, n); case 19: return Kd(e, t, n); case 22: return Bd(e, t, n); }throw Error(T(156, t.tag)); }; function up(e, t) { return $f(e, t); } function sy(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null; } function at(e, t, n, r) { return new sy(e, t, n, r); } function Ys(e) { return e = e.prototype, !(!e || !e.isReactComponent); } function ay(e) { if (typeof e == "function") return Ys(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === ps) return 11; if (e === hs) return 14; } return 2; } function rn(e, t) { var n = e.alternate; return n === null ? (n = at(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n; } function sl(e, t, n, r, o, l) { var i = 2; if (r = e, typeof e == "function") Ys(e) && (i = 1); else if (typeof e == "string") i = 5; else e: switch (e) { case Dn: return _n(n.children, o, l, t); case ds: i = 8, o |= 8; break; case lu: return e = at(12, n, t, o | 2), e.elementType = lu, e.lanes = l, e; case iu: return e = at(13, n, t, o), e.elementType = iu, e.lanes = l, e; case uu: return e = at(19, n, t, o), e.elementType = uu, e.lanes = l, e; case mf: return Zl(n, o, l, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case hf: i = 10; break e; case vf: i = 9; break e; case ps: i = 11; break e; case hs: i = 14; break e; case Wt: i = 16, r = null; break e; }throw Error(T(130, e == null ? e : typeof e, "")); }return t = at(i, n, t, o), t.elementType = e, t.type = r, t.lanes = l, t; } function _n(e, t, n, r) { return e = at(7, e, r, t), e.lanes = n, e; } function Zl(e, t, n, r) { return e = at(22, e, r, t), e.elementType = mf, e.lanes = n, e.stateNode = { isHidden: !1 }, e; } function Qi(e, t, n) { return e = at(6, e, null, t), e.lanes = n, e; } function Yi(e, t, n) { return t = at(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t; } function cy(e, t, n, r, o) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Li(0), this.expirationTimes = Li(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Li(0), this.identifierPrefix = r, this.onRecoverableError = o, this.mutableSourceEagerHydrationData = null; } function Zs(e, t, n, r, o, l, i, u, s) { return e = new cy(e, t, n, u, s), t === 1 ? (t = 1, l === !0 && (t |= 8)) : t = 0, l = at(3, null, null, t), e.current = l, l.stateNode = e, l.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Ms(l), e; } function fy(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Vn, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n }; } function sp(e) { if (!e) return ln; e = e._reactInternals; e: { if (An(e) !== e || e.tag !== 1) throw Error(T(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ge(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e; } }t = t.return; } while (t !== null); throw Error(T(171)); } if (e.tag === 1) { var n = e.type; if (Ge(n)) return ud(e, n, t); } return t; } function ap(e, t, n, r, o, l, i, u, s) { return e = Zs(n, r, !0, e, o, l, i, u, s), e.context = sp(null), n = e.current, r = Oe(), o = nn(n), l = Vt(r, o), l.callback = t ?? null, en(n, l, o), e.current.lanes = o, vo(e, o, r), Qe(e, r), e; } function bl(e, t, n, r) { var o = t.current, l = Oe(), i = nn(o); return n = sp(n), t.context === null ? t.context = n : t.pendingContext = n, t = Vt(l, i), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = en(o, t, i), e !== null && (wt(e, o, i, l), nl(e, o, i)), i; } function $l(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode; } } function Nc(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t; } } function bs(e, t) { Nc(e, t), (e = e.alternate) && Nc(e, t); } function dy() { return null; } var cp = typeof reportError == "function" ? reportError : function (e) { console.error(e); }; function Xs(e) { this._internalRoot = e; } Xl.prototype.render = Xs.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(T(409)); bl(e, t, null, null); }; Xl.prototype.unmount = Xs.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; kn(function () { bl(null, e, null, null); }), t[zt] = null; } }; function Xl(e) { this._internalRoot = e; } Xl.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Ff(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Gt.length && t !== 0 && t < Gt[n].priority; n++); Gt.splice(n, 0, e), n === 0 && jf(e); } }; function Js(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11); } function Jl(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")); } function Cc() { } function py(e, t, n, r, o) { if (o) { if (typeof r == "function") { var l = r; r = function () { var a = $l(i); l.call(a); }; } var i = ap(t, r, e, 0, null, !1, !1, "", Cc); return e._reactRootContainer = i, e[zt] = i.current, oo(e.nodeType === 8 ? e.parentNode : e), kn(), i; } for (; o = e.lastChild;)e.removeChild(o); if (typeof r == "function") { var u = r; r = function () { var a = $l(s); u.call(a); }; } var s = Zs(e, 0, !1, null, null, !1, !1, "", Cc); return e._reactRootContainer = s, e[zt] = s.current, oo(e.nodeType === 8 ? e.parentNode : e), kn(function () { bl(t, s, n, r); }), s; } function ql(e, t, n, r, o) { var l = n._reactRootContainer; if (l) { var i = l; if (typeof o == "function") { var u = o; o = function () { var s = $l(i); u.call(s); }; } bl(t, i, e, o); } else i = py(n, t, e, o, r); return $l(i); } Uf = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Vr(t.pendingLanes); n !== 0 && (ys(t, n | 1), Qe(t, we()), !(ee & 6) && (ur = we() + 500, an())); } break; case 13: kn(function () { var r = Ut(e, 1); if (r !== null) { var o = Oe(); wt(r, e, 1, o); } }), bs(e, 1); } }; gs = function (e) { if (e.tag === 13) { var t = Ut(e, 134217728); if (t !== null) { var n = Oe(); wt(t, e, 134217728, n); } bs(e, 134217728); } }; Of = function (e) { if (e.tag === 13) { var t = nn(e), n = Ut(e, t); if (n !== null) { var r = Oe(); wt(n, e, t, r); } bs(e, t); } }; Ff = function () { return ne; }; Bf = function (e, t) { var n = ne; try { return ne = e, t(); } finally { ne = n; } }; yu = function (e, t, n) { switch (t) { case "input": if (cu(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var o = Wl(r); if (!o) throw Error(T(90)); gf(r), cu(r, o); } } } break; case "textarea": _f(e, n); break; case "select": t = n.value, t != null && Qn(e, !!n.multiple, t, !1); } }; Cf = Ks; Lf = kn; var hy = { usingClientEntryPoint: !1, Events: [yo, Fn, Wl, kf, Nf, Ks] }, Cr = { findFiberByHostInstance: mn, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, vy = { bundleType: Cr.bundleType, version: Cr.version, rendererPackageName: Cr.rendererPackageName, rendererConfig: Cr.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ft.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Pf(e), e === null ? null : e.stateNode; }, findFiberByHostInstance: Cr.findFiberByHostInstance || dy, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Ko = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Ko.isDisabled && Ko.supportsFiber) try { Ol = Ko.inject(vy), Nt = Ko; } catch { } } nt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hy; nt.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Js(t)) throw Error(T(200)); return fy(e, t, null, n); }; nt.createRoot = function (e, t) { if (!Js(e)) throw Error(T(299)); var n = !1, r = "", o = cp; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), t = Zs(e, 1, !1, null, null, n, !1, r, o), e[zt] = t.current, oo(e.nodeType === 8 ? e.parentNode : e), new Xs(t); }; nt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(T(188)) : (e = Object.keys(e).join(","), Error(T(268, e))); return e = Pf(t), e = e === null ? null : e.stateNode, e; }; nt.flushSync = function (e) { return kn(e); }; nt.hydrate = function (e, t, n) { if (!Jl(t)) throw Error(T(200)); return ql(null, e, t, !0, n); }; nt.hydrateRoot = function (e, t, n) { if (!Js(e)) throw Error(T(405)); var r = n != null && n.hydratedSources || null, o = !1, l = "", i = cp; if (n != null && (n.unstable_strictMode === !0 && (o = !0), n.identifierPrefix !== void 0 && (l = n.identifierPrefix), n.onRecoverableError !== void 0 && (i = n.onRecoverableError)), t = ap(t, null, e, 1, n ?? null, o, !1, l, i), e[zt] = t.current, oo(e), r) for (e = 0; e < r.length; e++)n = r[e], o = n._getVersion, o = o(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, o] : t.mutableSourceEagerHydrationData.push(n, o); return new Xl(t); }; nt.render = function (e, t, n) { if (!Jl(t)) throw Error(T(200)); return ql(null, e, t, !1, n); }; nt.unmountComponentAtNode = function (e) { if (!Jl(e)) throw Error(T(40)); return e._reactRootContainer ? (kn(function () { ql(null, null, e, !1, function () { e._reactRootContainer = null, e[zt] = null; }); }), !0) : !1; }; nt.unstable_batchedUpdates = Ks; nt.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Jl(n)) throw Error(T(200)); if (e == null || e._reactInternals === void 0) throw Error(T(38)); return ql(e, t, n, !1, r); }; nt.version = "18.2.0-next-9e3b772b8-20220608"; function fp() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(fp); } catch (e) { console.error(e); } } fp(), af.exports = nt; var dp = af.exports; const my = Xc(dp); var Lc = dp; ru.createRoot = Lc.createRoot, ru.hydrateRoot = Lc.hydrateRoot; var pp = {}; function yy(e) { const t = new Error(e); if (t.stack === void 0) try { throw t; } catch { } return t; } var gy = yy, b = gy; function Sy(e) { return !!e && typeof e.then == "function"; } var se = Sy; function _y(e, t) { if (e != null) return e; throw b(t ?? "Got unexpected null or undefined"); } var ve = _y; function Y(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e; } class ei { getValue() { throw b("BaseLoadable"); } toPromise() { throw b("BaseLoadable"); } valueMaybe() { throw b("BaseLoadable"); } valueOrThrow() { throw b(`Loadable expected value, but in "${this.state}" state`); } promiseMaybe() { throw b("BaseLoadable"); } promiseOrThrow() { throw b(`Loadable expected promise, but in "${this.state}" state`); } errorMaybe() { throw b("BaseLoadable"); } errorOrThrow() { throw b(`Loadable expected error, but in "${this.state}" state`); } is(t) { return t.state === this.state && t.contents === this.contents; } map(t) { throw b("BaseLoadable"); } } class wy extends ei { constructor(t) { super(), Y(this, "state", "hasValue"), Y(this, "contents", void 0), this.contents = t; } getValue() { return this.contents; } toPromise() { return Promise.resolve(this.contents); } valueMaybe() { return this.contents; } valueOrThrow() { return this.contents; } promiseMaybe() { } errorMaybe() { } map(t) { try { const n = t(this.contents); return se(n) ? Nn(n) : sr(n) ? n : So(n); } catch (n) { return se(n) ? Nn(n.next(() => this.map(t))) : ti(n); } } } class Ry extends ei { constructor(t) { super(), Y(this, "state", "hasError"), Y(this, "contents", void 0), this.contents = t; } getValue() { throw this.contents; } toPromise() { return Promise.reject(this.contents); } valueMaybe() { } promiseMaybe() { } errorMaybe() { return this.contents; } errorOrThrow() { return this.contents; } map(t) { return this; } } class hp extends ei { constructor(t) { super(), Y(this, "state", "loading"), Y(this, "contents", void 0), this.contents = t; } getValue() { throw this.contents; } toPromise() { return this.contents; } valueMaybe() { } promiseMaybe() { return this.contents; } promiseOrThrow() { return this.contents; } errorMaybe() { } map(t) { return Nn(this.contents.then(n => { const r = t(n); if (sr(r)) { const o = r; switch (o.state) { case "hasValue": return o.contents; case "hasError": throw o.contents; case "loading": return o.contents; } } return r; }).catch(n => { if (se(n)) return n.then(() => this.map(t).contents); throw n; })); } } function So(e) { return Object.freeze(new wy(e)); } function ti(e) { return Object.freeze(new Ry(e)); } function Nn(e) { return Object.freeze(new hp(e)); } function vp() { return Object.freeze(new hp(new Promise(() => { }))); } function Ey(e) { return e.every(t => t.state === "hasValue") ? So(e.map(t => t.contents)) : e.some(t => t.state === "hasError") ? ti(ve(e.find(t => t.state === "hasError"), "Invalid loadable passed to loadableAll").contents) : Nn(Promise.all(e.map(t => t.contents))); } function mp(e) { const n = (Array.isArray(e) ? e : Object.getOwnPropertyNames(e).map(o => e[o])).map(o => sr(o) ? o : se(o) ? Nn(o) : So(o)), r = Ey(n); return Array.isArray(e) ? r : r.map(o => Object.getOwnPropertyNames(e).reduce((l, i, u) => ({ ...l, [i]: o[u] }), {})); } function sr(e) { return e instanceof ei; } const Ty = { of: e => se(e) ? Nn(e) : sr(e) ? e : So(e), error: e => ti(e), loading: () => vp(), all: mp, isLoadable: sr }; var xn = { loadableWithValue: So, loadableWithError: ti, loadableWithPromise: Nn, loadableLoading: vp, loadableAll: mp, isLoadable: sr, RecoilLoadable: Ty }, ky = xn.loadableWithValue, Ny = xn.loadableWithError, Cy = xn.loadableWithPromise, Ly = xn.loadableLoading, Ay = xn.loadableAll, xy = xn.isLoadable, Py = xn.RecoilLoadable, _o = Object.freeze({ __proto__: null, loadableWithValue: ky, loadableWithError: Ny, loadableWithPromise: Cy, loadableLoading: Ly, loadableAll: Ay, isLoadable: xy, RecoilLoadable: Py }); const bu = { RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: !0, RECOIL_GKS_ENABLED: new Set(["recoil_hamt_2020", "recoil_sync_external_store", "recoil_suppress_rerender_in_callback", "recoil_memory_managament_2020"]) }; function My(e, t) { var n, r; const o = (n = pp[e]) === null || n === void 0 || (r = n.toLowerCase()) === null || r === void 0 ? void 0 : r.trim(); if (o == null || o === "") return; if (!["true", "false"].includes(o)) throw b(`process.env.${e} value must be 'true', 'false', or empty: ${o}`); t(o === "true"); } function $y(e, t) { var n; const r = (n = pp[e]) === null || n === void 0 ? void 0 : n.trim(); r == null || r === "" || t(r.split(/\s*,\s*|\s+/)); } function Iy() { var e; typeof process > "u" || ((e = process) === null || e === void 0 ? void 0 : e.env) != null && (My("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED", t => { bu.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = t; }), $y("RECOIL_GKS_ENABLED", t => { t.forEach(n => { bu.RECOIL_GKS_ENABLED.add(n); }); })); } Iy(); var mr = bu; function ni(e) { return mr.RECOIL_GKS_ENABLED.has(e); } ni.setPass = e => { mr.RECOIL_GKS_ENABLED.add(e); }; ni.setFail = e => { mr.RECOIL_GKS_ENABLED.delete(e); }; ni.clear = () => { mr.RECOIL_GKS_ENABLED.clear(); }; var le = ni; function Vy(e, t, { error: n } = {}) { return null; } var Dy = Vy, qs = Dy, Zi, bi, Xi; const zy = (Zi = ce.createMutableSource) !== null && Zi !== void 0 ? Zi : ce.unstable_createMutableSource, yp = (bi = ce.useMutableSource) !== null && bi !== void 0 ? bi : ce.unstable_useMutableSource, gp = (Xi = ce.useSyncExternalStore) !== null && Xi !== void 0 ? Xi : ce.unstable_useSyncExternalStore; function Uy() { var e; const { ReactCurrentDispatcher: t, ReactCurrentOwner: n } = ce.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; return ((e = t == null ? void 0 : t.current) !== null && e !== void 0 ? e : n.currentDispatcher).useSyncExternalStore != null; } function Oy() { return le("recoil_transition_support") ? { mode: "TRANSITION_SUPPORT", early: !0, concurrent: !0 } : le("recoil_sync_external_store") && gp != null ? { mode: "SYNC_EXTERNAL_STORE", early: !0, concurrent: !1 } : le("recoil_mutable_source") && yp != null && typeof window < "u" && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE ? le("recoil_suppress_rerender_in_callback") ? { mode: "MUTABLE_SOURCE", early: !0, concurrent: !0 } : { mode: "MUTABLE_SOURCE", early: !1, concurrent: !1 } : le("recoil_suppress_rerender_in_callback") ? { mode: "LEGACY", early: !0, concurrent: !1 } : { mode: "LEGACY", early: !1, concurrent: !1 }; } function Fy() { return !1; } var wo = { createMutableSource: zy, useMutableSource: yp, useSyncExternalStore: gp, currentRendererSupportsUseSyncExternalStore: Uy, reactMode: Oy, isFastRefreshEnabled: Fy }; class ea { constructor(t) { Y(this, "key", void 0), this.key = t; } toJSON() { return { key: this.key }; } } class Sp extends ea { } class _p extends ea { } function By(e) { return e instanceof Sp || e instanceof _p; } var ri = { AbstractRecoilValue: ea, RecoilState: Sp, RecoilValueReadOnly: _p, isRecoilValue: By }, jy = ri.AbstractRecoilValue, Wy = ri.RecoilState, Hy = ri.RecoilValueReadOnly, Ky = ri.isRecoilValue, ar = Object.freeze({ __proto__: null, AbstractRecoilValue: jy, RecoilState: Wy, RecoilValueReadOnly: Hy, isRecoilValue: Ky }); function Gy(e, t) { return function* () { let n = 0; for (const r of e) yield t(r, n++); }(); } var oi = Gy; class wp { } const Qy = new wp, Cn = new Map, ta = new Map; function Yy(e) { return oi(e, t => ve(ta.get(t))); } function Zy(e) {
    if (Cn.has(e)) {
      const t = `Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`; console.warn(t);
    }
  } function by(e) { mr.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED && Zy(e.key), Cn.set(e.key, e); const t = e.set == null ? new ar.RecoilValueReadOnly(e.key) : new ar.RecoilState(e.key); return ta.set(e.key, t), t; } class Rp extends Error { } function Xy(e) { const t = Cn.get(e); if (t == null) throw new Rp(`Missing definition for RecoilValue: "${e}""`); return t; } function Jy(e) { return Cn.get(e); } const Il = new Map; function qy(e) { var t; if (!le("recoil_memory_managament_2020")) return; const n = Cn.get(e); if (n != null && (t = n.shouldDeleteConfigOnRelease) !== null && t !== void 0 && t.call(n)) { var r; Cn.delete(e), (r = Ep(e)) === null || r === void 0 || r(), Il.delete(e); } } function e0(e, t) { le("recoil_memory_managament_2020") && (t === void 0 ? Il.delete(e) : Il.set(e, t)); } function Ep(e) { return Il.get(e); } var Ze = { nodes: Cn, recoilValues: ta, registerNode: by, getNode: Xy, getNodeMaybe: Jy, deleteNodeConfigIfPossible: qy, setConfigDeletionHandler: e0, getConfigDeletionHandler: Ep, recoilValuesForKeys: Yy, NodeMissingError: Rp, DefaultValue: wp, DEFAULT_VALUE: Qy }; function t0(e, t) { t(); } var n0 = { enqueueExecution: t0 }; function r0(e, t) { return t = { exports: {} }, e(t, t.exports), t.exports; } var o0 = r0(function (e) { var t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (g) { return typeof g; } : function (g) { return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g; }, n = {}, r = 5, o = Math.pow(2, r), l = o - 1, i = o / 2, u = o / 4, s = {}, a = function (v) { return function () { return v; }; }, f = n.hash = function (g) { var v = typeof g > "u" ? "undefined" : t(g); if (v === "number") return g; v !== "string" && (g += ""); for (var E = 0, x = 0, P = g.length; x < P; ++x) { var z = g.charCodeAt(x); E = (E << 5) - E + z | 0; } return E; }, p = function (v) { return v -= v >> 1 & 1431655765, v = (v & 858993459) + (v >> 2 & 858993459), v = v + (v >> 4) & 252645135, v += v >> 8, v += v >> 16, v & 127; }, m = function (v, E) { return E >>> v & l; }, _ = function (v) { return 1 << v; }, S = function (v, E) { return p(v & E - 1); }, w = function (v, E, x, P) { var z = P; if (!v) { var G = P.length; z = new Array(G); for (var W = 0; W < G; ++W)z[W] = P[W]; } return z[E] = x, z; }, B = function (v, E, x) { var P = x.length - 1, z = 0, G = 0, W = x; if (v) z = G = E; else for (W = new Array(P); z < E;)W[G++] = x[z++]; for (++z; z <= P;)W[G++] = x[z++]; return v && (W.length = P), W; }, h = function (v, E, x, P) { var z = P.length; if (v) { for (var G = z; G >= E;)P[G--] = P[G]; return P[E] = x, P; } for (var W = 0, H = 0, X = new Array(z + 1); W < E;)X[H++] = P[W++]; for (X[E] = x; W < z;)X[++H] = P[W++]; return X; }, c = 1, d = 2, R = 3, k = 4, C = { __hamt_isEmpty: !0 }, L = function (v) { return v === C || v && v.__hamt_isEmpty; }, I = function (v, E, x, P) { return { type: c, edit: v, hash: E, key: x, value: P, _modify: M }; }, te = function (v, E, x) { return { type: d, edit: v, hash: E, children: x, _modify: j }; }, U = function (v, E, x) { return { type: R, edit: v, mask: E, children: x, _modify: $ }; }, fe = function (v, E, x) { return { type: k, edit: v, size: E, children: x, _modify: O }; }, ot = function (v) { return v === C || v.type === c || v.type === d; }, re = function (v, E, x, P, z) { for (var G = [], W = P, H = 0, X = 0; W; ++X)W & 1 && (G[X] = z[H++]), W >>>= 1; return G[E] = x, fe(v, H + 1, G); }, Me = function (v, E, x, P) { for (var z = new Array(E - 1), G = 0, W = 0, H = 0, X = P.length; H < X; ++H)if (H !== x) { var pe = P[H]; pe && !L(pe) && (z[G++] = pe, W |= 1 << H); } return U(v, W, z); }, xt = function g(v, E, x, P, z, G) { if (x === z) return te(v, x, [G, P]); var W = m(E, x), H = m(E, z); return U(v, _(W) | _(H), W === H ? [g(v, E + r, x, P, z, G)] : W < H ? [P, G] : [G, P]); }, $e = function (v, E, x, P, z, G, W, H) { for (var X = z.length, pe = 0; pe < X; ++pe) { var je = z[pe]; if (x(W, je.key)) { var Ne = je.value, it = G(Ne); return it === Ne ? z : it === s ? (--H.value, B(v, pe, z)) : w(v, pe, I(E, P, W, it), z); } } var ht = G(); return ht === s ? z : (++H.value, w(v, X, I(E, P, W, ht), z)); }, be = function (v, E) { return v === E.edit; }, M = function (v, E, x, P, z, G, W) { if (E(G, this.key)) { var H = P(this.value); return H === this.value ? this : H === s ? (--W.value, C) : be(v, this) ? (this.value = H, this) : I(v, z, G, H); } var X = P(); return X === s ? this : (++W.value, xt(v, x, this.hash, this, z, I(v, z, G, X))); }, j = function (v, E, x, P, z, G, W) { if (z === this.hash) { var H = be(v, this), X = $e(H, v, E, this.hash, this.children, P, G, W); return X === this.children ? this : X.length > 1 ? te(v, this.hash, X) : X[0]; } var pe = P(); return pe === s ? this : (++W.value, xt(v, x, this.hash, this, z, I(v, z, G, pe))); }, $ = function (v, E, x, P, z, G, W) { var H = this.mask, X = this.children, pe = m(x, z), je = _(pe), Ne = S(H, je), it = H & je, ht = it ? X[Ne] : C, Mn = ht._modify(v, E, x + r, P, z, G, W); if (ht === Mn) return this; var Lo = be(v, this), gr = H, Sr = void 0; if (it && L(Mn)) { if (gr &= ~je, !gr) return C; if (X.length <= 2 && ot(X[Ne ^ 1])) return X[Ne ^ 1]; Sr = B(Lo, Ne, X); } else if (!it && !L(Mn)) { if (X.length >= i) return re(v, pe, Mn, H, X); gr |= je, Sr = h(Lo, Ne, Mn, X); } else Sr = w(Lo, Ne, Mn, X); return Lo ? (this.mask = gr, this.children = Sr, this) : U(v, gr, Sr); }, O = function (v, E, x, P, z, G, W) { var H = this.size, X = this.children, pe = m(x, z), je = X[pe], Ne = (je || C)._modify(v, E, x + r, P, z, G, W); if (je === Ne) return this; var it = be(v, this), ht = void 0; if (L(je) && !L(Ne)) ++H, ht = w(it, pe, Ne, X); else if (!L(je) && L(Ne)) { if (--H, H <= u) return Me(v, H, pe, X); ht = w(it, pe, C, X); } else ht = w(it, pe, Ne, X); return it ? (this.size = H, this.children = ht, this) : fe(v, H, ht); }; C._modify = function (g, v, E, x, P, z, G) { var W = x(); return W === s ? C : (++G.value, I(g, P, z, W)); }; function y(g, v, E, x, P) { this._editable = g, this._edit = v, this._config = E, this._root = x, this._size = P; } y.prototype.setTree = function (g, v) { return this._editable ? (this._root = g, this._size = v, this) : g === this._root ? this : new y(this._editable, this._edit, this._config, g, v); }; var N = n.tryGetHash = function (g, v, E, x) { for (var P = x._root, z = 0, G = x._config.keyEq; ;)switch (P.type) { case c: return G(E, P.key) ? P.value : g; case d: { if (v === P.hash) for (var W = P.children, H = 0, X = W.length; H < X; ++H) { var pe = W[H]; if (G(E, pe.key)) return pe.value; } return g; } case R: { var je = m(z, v), Ne = _(je); if (P.mask & Ne) { P = P.children[S(P.mask, Ne)], z += r; break; } return g; } case k: { if (P = P.children[m(z, v)], P) { z += r; break; } return g; } default: return g; } }; y.prototype.tryGetHash = function (g, v, E) { return N(g, v, E, this); }; var A = n.tryGet = function (g, v, E) { return N(g, E._config.hash(v), v, E); }; y.prototype.tryGet = function (g, v) { return A(g, v, this); }; var K = n.getHash = function (g, v, E) { return N(void 0, g, v, E); }; y.prototype.getHash = function (g, v) { return K(g, v, this); }, n.get = function (g, v) { return N(void 0, v._config.hash(g), g, v); }, y.prototype.get = function (g, v) { return A(v, g, this); }; var V = n.has = function (g, v, E) { return N(s, g, v, E) !== s; }; y.prototype.hasHash = function (g, v) { return V(g, v, this); }; var Z = n.has = function (g, v) { return V(v._config.hash(g), g, v); }; y.prototype.has = function (g) { return Z(g, this); }; var J = function (v, E) { return v === E; }; n.make = function (g) { return new y(0, 0, { keyEq: g && g.keyEq || J, hash: g && g.hash || f }, C, 0); }, n.empty = n.make(); var F = n.isEmpty = function (g) { return g && !!L(g._root); }; y.prototype.isEmpty = function () { return F(this); }; var de = n.modifyHash = function (g, v, E, x) { var P = { value: x._size }, z = x._root._modify(x._editable ? x._edit : NaN, x._config.keyEq, 0, g, v, E, P); return x.setTree(z, P.value); }; y.prototype.modifyHash = function (g, v, E) { return de(E, g, v, this); }; var Ee = n.modify = function (g, v, E) { return de(g, E._config.hash(v), v, E); }; y.prototype.modify = function (g, v) { return Ee(v, g, this); }; var oe = n.setHash = function (g, v, E, x) { return de(a(E), g, v, x); }; y.prototype.setHash = function (g, v, E) { return oe(g, v, E, this); }; var me = n.set = function (g, v, E) { return oe(E._config.hash(g), g, v, E); }; y.prototype.set = function (g, v) { return me(g, v, this); }; var pt = a(s), dn = n.removeHash = function (g, v, E) { return de(pt, g, v, E); }; y.prototype.removeHash = y.prototype.deleteHash = function (g, v) { return dn(g, v, this); }; var lt = n.remove = function (g, v) { return dn(v._config.hash(g), g, v); }; y.prototype.remove = y.prototype.delete = function (g) { return lt(g, this); }; var Xe = n.beginMutation = function (g) { return new y(g._editable + 1, g._edit + 1, g._config, g._root, g._size); }; y.prototype.beginMutation = function () { return Xe(this); }; var ma = n.endMutation = function (g) { return g._editable = g._editable && g._editable - 1, g; }; y.prototype.endMutation = function () { return ma(this); }; var Dh = n.mutate = function (g, v) { var E = Xe(v); return g(E), ma(E); }; y.prototype.mutate = function (g) { return Dh(g, this); }; var _i = function (v) { return v && ya(v[0], v[1], v[2], v[3], v[4]); }, ya = function (v, E, x, P, z) { for (; x < v;) { var G = E[x++]; if (G && !L(G)) return ga(G, P, [v, E, x, P, z]); } return _i(z); }, ga = function (v, E, x) { switch (v.type) { case c: return { value: E(v), rest: x }; case d: case k: case R: var P = v.children; return ya(P.length, P, 0, E, x); default: return _i(x); } }, zh = { done: !0 }; function wi(g) { this.v = g; } wi.prototype.next = function () { if (!this.v) return zh; var g = this.v; return this.v = _i(g.rest), g; }, wi.prototype[Symbol.iterator] = function () { return this; }; var Ri = function (v, E) { return new wi(ga(v._root, E)); }, Uh = function (v) { return [v.key, v.value]; }, Oh = n.entries = function (g) { return Ri(g, Uh); }; y.prototype.entries = y.prototype[Symbol.iterator] = function () { return Oh(this); }; var Fh = function (v) { return v.key; }, Bh = n.keys = function (g) { return Ri(g, Fh); }; y.prototype.keys = function () { return Bh(this); }; var jh = function (v) { return v.value; }, Wh = n.values = y.prototype.values = function (g) { return Ri(g, jh); }; y.prototype.values = function () { return Wh(this); }; var Sa = n.fold = function (g, v, E) { var x = E._root; if (x.type === c) return g(v, x.value, x.key); for (var P = [x.children], z = void 0; z = P.pop();)for (var G = 0, W = z.length; G < W;) { var H = z[G++]; H && H.type && (H.type === c ? v = g(v, H.value, H.key) : P.push(H.children)); } return v; }; y.prototype.fold = function (g, v) { return Sa(g, v, this); }; var Hh = n.forEach = function (g, v) { return Sa(function (E, x, P) { return g(x, P, v); }, null, v); }; y.prototype.forEach = function (g) { return Hh(g, this); }; var Kh = n.count = function (g) { return g._size; }; y.prototype.count = function () { return Kh(this); }, Object.defineProperty(y.prototype, "size", { get: y.prototype.count }), e.exports ? e.exports = n : (void 0).hamt = n; }); class l0 { constructor(t) { Y(this, "_map", void 0), this._map = new Map(t == null ? void 0 : t.entries()); } keys() { return this._map.keys(); } entries() { return this._map.entries(); } get(t) { return this._map.get(t); } has(t) { return this._map.has(t); } set(t, n) { return this._map.set(t, n), this; } delete(t) { return this._map.delete(t), this; } clone() { return ra(this); } toMap() { return new Map(this._map); } } class na { constructor(t) { if (Y(this, "_hamt", o0.empty.beginMutation()), t instanceof na) { const n = t._hamt.endMutation(); t._hamt = n.beginMutation(), this._hamt = n.beginMutation(); } else if (t) for (const [n, r] of t.entries()) this._hamt.set(n, r); } keys() { return this._hamt.keys(); } entries() { return this._hamt.entries(); } get(t) { return this._hamt.get(t); } has(t) { return this._hamt.has(t); } set(t, n) { return this._hamt.set(t, n), this; } delete(t) { return this._hamt.delete(t), this; } clone() { return ra(this); } toMap() { return new Map(this._hamt); } } function ra(e) { return le("recoil_hamt_2020") ? new na(e) : new l0(e); } var i0 = { persistentMap: ra }, u0 = i0.persistentMap, s0 = Object.freeze({ __proto__: null, persistentMap: u0 }); function a0(e, ...t) { const n = new Set; e: for (const r of e) { for (const o of t) if (o.has(r)) continue e; n.add(r); } return n; } var Qr = a0; function c0(e, t) { const n = new Map; return e.forEach((r, o) => { n.set(o, t(r, o)); }), n; } var Vl = c0; function f0() { return { nodeDeps: new Map, nodeToNodeSubscriptions: new Map }; } function d0(e) { return { nodeDeps: Vl(e.nodeDeps, t => new Set(t)), nodeToNodeSubscriptions: Vl(e.nodeToNodeSubscriptions, t => new Set(t)) }; } function Ji(e, t, n, r) { const { nodeDeps: o, nodeToNodeSubscriptions: l } = n, i = o.get(e); if (i && r && i !== r.nodeDeps.get(e)) return; o.set(e, t); const u = i == null ? t : Qr(t, i); for (const s of u) l.has(s) || l.set(s, new Set), ve(l.get(s)).add(e); if (i) { const s = Qr(i, t); for (const a of s) { if (!l.has(a)) return; const f = ve(l.get(a)); f.delete(e), f.size === 0 && l.delete(a); } } } function p0(e, t, n, r) { var o, l, i, u; const s = n.getState(); r === s.currentTree.version || r === ((o = s.nextTree) === null || o === void 0 ? void 0 : o.version) || ((l = s.previousTree) === null || l === void 0 || l.version); const a = n.getGraph(r); if (Ji(e, t, a), r === ((i = s.previousTree) === null || i === void 0 ? void 0 : i.version)) { const p = n.getGraph(s.currentTree.version); Ji(e, t, p, a); } if (r === ((u = s.previousTree) === null || u === void 0 ? void 0 : u.version) || r === s.currentTree.version) { var f; const p = (f = s.nextTree) === null || f === void 0 ? void 0 : f.version; if (p !== void 0) { const m = n.getGraph(p); Ji(e, t, m, a); } } } var Ro = { cloneGraph: d0, graph: f0, saveDepsToStore: p0 }; let h0 = 0; const v0 = () => h0++; let m0 = 0; const y0 = () => m0++; let g0 = 0; const S0 = () => g0++; var li = { getNextTreeStateVersion: v0, getNextStoreID: y0, getNextComponentID: S0 }; const { persistentMap: Ac } = s0, { graph: _0 } = Ro, { getNextTreeStateVersion: Tp } = li; function kp() { const e = Tp(); return { version: e, stateID: e, transactionMetadata: {}, dirtyAtoms: new Set, atomValues: Ac(), nonvalidatedAtoms: Ac() }; } function w0() { const e = kp(); return { currentTree: e, nextTree: null, previousTree: null, commitDepth: 0, knownAtoms: new Set, knownSelectors: new Set, transactionSubscriptions: new Map, nodeTransactionSubscriptions: new Map, nodeToComponentSubscriptions: new Map, queuedComponentCallbacks_DEPRECATED: [], suspendedComponentResolvers: new Set, graphsByVersion: new Map().set(e.version, _0()), retention: { referenceCounts: new Map, nodesRetainedByZone: new Map, retainablesToCheckForRelease: new Set }, nodeCleanupFunctions: new Map }; } var Np = { makeEmptyTreeState: kp, makeEmptyStoreState: w0, getNextTreeStateVersion: Tp }; class Cp { } function R0() { return new Cp; } var ii = { RetentionZone: Cp, retentionZone: R0 }; function E0(e, t) { const n = new Set(e); return n.add(t), n; } function T0(e, t) { const n = new Set(e); return n.delete(t), n; } function k0(e, t, n) { const r = new Map(e); return r.set(t, n), r; } function N0(e, t, n) { const r = new Map(e); return r.set(t, n(r.get(t))), r; } function C0(e, t) { const n = new Map(e); return n.delete(t), n; } function L0(e, t) { const n = new Map(e); return t.forEach(r => n.delete(r)), n; } var Lp = { setByAddingToSet: E0, setByDeletingFromSet: T0, mapBySettingInMap: k0, mapByUpdatingInMap: N0, mapByDeletingFromMap: C0, mapByDeletingMultipleFromMap: L0 }; function* A0(e, t) { let n = 0; for (const r of e) t(r, n++) && (yield r); } var oa = A0; function x0(e, t) { return new Proxy(e, { get: (r, o) => (!(o in r) && o in t && (r[o] = t[o]()), r[o]), ownKeys: r => Object.keys(r) }); } var Ap = x0; const { getNode: Eo, getNodeMaybe: P0, recoilValuesForKeys: xc } = Ze, { RetentionZone: Pc } = ii, { setByAddingToSet: M0 } = Lp, $0 = Object.freeze(new Set); class I0 extends Error { } function V0(e, t, n) { if (!le("recoil_memory_managament_2020")) return () => { }; const { nodesRetainedByZone: r } = e.getState().retention; function o(l) { let i = r.get(l); i || r.set(l, i = new Set), i.add(t); } if (n instanceof Pc) o(n); else if (Array.isArray(n)) for (const l of n) o(l); return () => { if (!le("recoil_memory_managament_2020")) return; const { retention: l } = e.getState(); function i(u) { const s = l.nodesRetainedByZone.get(u); s == null || s.delete(t), s && s.size === 0 && l.nodesRetainedByZone.delete(u); } if (n instanceof Pc) i(n); else if (Array.isArray(n)) for (const u of n) i(u); }; } function la(e, t, n, r) { const o = e.getState(); if (o.nodeCleanupFunctions.has(n)) return; const l = Eo(n), i = V0(e, n, l.retainedBy), u = l.init(e, t, r); o.nodeCleanupFunctions.set(n, () => { u(), i(); }); } function D0(e, t, n) { la(e, e.getState().currentTree, t, n); } function z0(e, t) { var n; const r = e.getState(); (n = r.nodeCleanupFunctions.get(t)) === null || n === void 0 || n(), r.nodeCleanupFunctions.delete(t); } function U0(e, t, n) { return la(e, t, n, "get"), Eo(n).get(e, t); } function xp(e, t, n) { return Eo(n).peek(e, t); } function O0(e, t, n) { var r; const o = P0(t); return o == null || (r = o.invalidate) === null || r === void 0 || r.call(o, e), { ...e, atomValues: e.atomValues.clone().delete(t), nonvalidatedAtoms: e.nonvalidatedAtoms.clone().set(t, n), dirtyAtoms: M0(e.dirtyAtoms, t) }; } function F0(e, t, n, r) { const o = Eo(n); if (o.set == null) throw new I0(`Attempt to set read-only RecoilValue: ${n}`); const l = o.set; return la(e, t, n, "set"), l(e, t, r); } function B0(e, t, n) { const r = e.getState(), o = e.getGraph(t.version), l = Eo(n).nodeType; return Ap({ type: l }, { loadable: () => xp(e, t, n), isActive: () => r.knownAtoms.has(n) || r.knownSelectors.has(n), isSet: () => l === "selector" ? !1 : t.atomValues.has(n), isModified: () => t.dirtyAtoms.has(n), deps: () => { var i; return xc((i = o.nodeDeps.get(n)) !== null && i !== void 0 ? i : []); }, subscribers: () => { var i, u; return { nodes: xc(oa(Pp(e, t, new Set([n])), s => s !== n)), components: oi((i = (u = r.nodeToComponentSubscriptions.get(n)) === null || u === void 0 ? void 0 : u.values()) !== null && i !== void 0 ? i : [], ([s]) => ({ name: s })) }; } }); } function Pp(e, t, n) { const r = new Set, o = Array.from(n), l = e.getGraph(t.version); for (let u = o.pop(); u; u = o.pop()) { var i; r.add(u); const s = (i = l.nodeToNodeSubscriptions.get(u)) !== null && i !== void 0 ? i : $0; for (const a of s) r.has(a) || o.push(a); } return r; } var cn = { getNodeLoadable: U0, peekNodeLoadable: xp, setNodeValue: F0, initializeNode: D0, cleanUpNode: z0, setUnvalidatedAtomValue_DEPRECATED: O0, peekNodeInfo: B0, getDownstreamNodes: Pp }; let Mp = null; function j0(e) { Mp = e; } function W0() { var e; (e = Mp) === null || e === void 0 || e(); } var $p = { setInvalidateMemoizedSnapshot: j0, invalidateMemoizedSnapshot: W0 }; const { getDownstreamNodes: H0, getNodeLoadable: Ip, setNodeValue: K0 } = cn, { getNextComponentID: G0 } = li, { getNode: Q0, getNodeMaybe: Vp } = Ze, { DefaultValue: ia } = Ze, { reactMode: Y0 } = wo, { AbstractRecoilValue: Z0, RecoilState: b0, RecoilValueReadOnly: X0, isRecoilValue: J0 } = ar, { invalidateMemoizedSnapshot: q0 } = $p; function eg(e, { key: t }, n = e.getState().currentTree) { var r, o; const l = e.getState(); n.version === l.currentTree.version || n.version === ((r = l.nextTree) === null || r === void 0 ? void 0 : r.version) || (n.version, (o = l.previousTree) === null || o === void 0 || o.version); const i = Ip(e, n, t); return i.state === "loading" && i.contents.catch(() => { }), i; } function tg(e, t) { const n = e.clone(); return t.forEach((r, o) => { r.state === "hasValue" && r.contents instanceof ia ? n.delete(o) : n.set(o, r); }), n; } function ng(e, t, { key: n }, r) { if (typeof r == "function") { const o = Ip(e, t, n); if (o.state === "loading") { const l = `Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`; throw b(l); } else if (o.state === "hasError") throw o.contents; return r(o.contents); } else return r; } function rg(e, t, n) { if (n.type === "set") { const { recoilValue: o, valueOrUpdater: l } = n, i = ng(e, t, o, l), u = K0(e, t, o.key, i); for (const [s, a] of u.entries()) Xu(t, s, a); } else if (n.type === "setLoadable") { const { recoilValue: { key: o }, loadable: l } = n; Xu(t, o, l); } else if (n.type === "markModified") { const { recoilValue: { key: o } } = n; t.dirtyAtoms.add(o); } else if (n.type === "setUnvalidated") { var r; const { recoilValue: { key: o }, unvalidatedValue: l } = n, i = Vp(o); i == null || (r = i.invalidate) === null || r === void 0 || r.call(i, t), t.atomValues.delete(o), t.nonvalidatedAtoms.set(o, l), t.dirtyAtoms.add(o); } else qs(`Unknown action ${n.type}`); } function Xu(e, t, n) { n.state === "hasValue" && n.contents instanceof ia ? e.atomValues.delete(t) : e.atomValues.set(t, n), e.dirtyAtoms.add(t), e.nonvalidatedAtoms.delete(t); } function Dp(e, t) { e.replaceState(n => { const r = zp(n); for (const o of t) rg(e, r, o); return Up(e, r), q0(), r; }); } function ui(e, t) { if (Yr.length) { const n = Yr[Yr.length - 1]; let r = n.get(e); r || n.set(e, r = []), r.push(t); } else Dp(e, [t]); } const Yr = []; function og() { const e = new Map; return Yr.push(e), () => { for (const [t, n] of e) Dp(t, n); Yr.pop(); }; } function zp(e) { return { ...e, atomValues: e.atomValues.clone(), nonvalidatedAtoms: e.nonvalidatedAtoms.clone(), dirtyAtoms: new Set(e.dirtyAtoms) }; } function Up(e, t) { const n = H0(e, t, t.dirtyAtoms); for (const l of n) { var r, o; (r = Vp(l)) === null || r === void 0 || (o = r.invalidate) === null || o === void 0 || o.call(r, t); } } function Op(e, t, n) { ui(e, { type: "set", recoilValue: t, valueOrUpdater: n }); } function lg(e, t, n) { if (n instanceof ia) return Op(e, t, n); ui(e, { type: "setLoadable", recoilValue: t, loadable: n }); } function ig(e, t) { ui(e, { type: "markModified", recoilValue: t }); } function ug(e, t, n) { ui(e, { type: "setUnvalidated", recoilValue: t, unvalidatedValue: n }); } function sg(e, { key: t }, n, r = null) { const o = G0(), l = e.getState(); l.nodeToComponentSubscriptions.has(t) || l.nodeToComponentSubscriptions.set(t, new Map), ve(l.nodeToComponentSubscriptions.get(t)).set(o, [r ?? "<not captured>", n]); const i = Y0(); if (i.early && (i.mode === "LEGACY" || i.mode === "MUTABLE_SOURCE")) { const u = e.getState().nextTree; u && u.dirtyAtoms.has(t) && n(u); } return { release: () => { const u = e.getState(), s = u.nodeToComponentSubscriptions.get(t); s === void 0 || !s.has(o) || (s.delete(o), s.size === 0 && u.nodeToComponentSubscriptions.delete(t)); } }; } function ag(e, t) { var n; const { currentTree: r } = e.getState(), o = Q0(t.key); (n = o.clearCache) === null || n === void 0 || n.call(o, e, r); } var Lt = { RecoilValueReadOnly: X0, AbstractRecoilValue: Z0, RecoilState: b0, getRecoilValueAsLoadable: eg, setRecoilValue: Op, setRecoilValueLoadable: lg, markRecoilValueModified: ig, setUnvalidatedRecoilValue: ug, subscribeToRecoilValue: sg, isRecoilValue: J0, applyAtomValueWrites: tg, batchStart: og, writeLoadableToTreeState: Xu, invalidateDownstreams: Up, copyTreeState: zp, refreshRecoilValue: ag }; function cg(e, t, n) { const r = e.entries(); let o = r.next(); for (; !o.done;) { const l = o.value; if (t.call(n, l[1], l[0], e)) return !0; o = r.next(); } return !1; } var fg = cg; const { cleanUpNode: dg } = cn, { deleteNodeConfigIfPossible: pg, getNode: Fp } = Ze, { RetentionZone: Bp } = ii, hg = 12e4, jp = new Set; function Wp(e, t) { const n = e.getState(), r = n.currentTree; if (n.nextTree) return; const o = new Set; for (const i of t) if (i instanceof Bp) for (const u of gg(n, i)) o.add(u); else o.add(i); const l = vg(e, o); for (const i of l) yg(e, r, i); } function vg(e, t) { const n = e.getState(), r = n.currentTree, o = e.getGraph(r.version), l = new Set, i = new Set; return u(t), l; function u(s) { const a = new Set, f = mg(e, r, s, l, i); for (const S of f) { var p; if (Fp(S).retainedBy === "recoilRoot") { i.add(S); continue; } if (((p = n.retention.referenceCounts.get(S)) !== null && p !== void 0 ? p : 0) > 0) { i.add(S); continue; } if (Hp(S).some(B => n.retention.referenceCounts.get(B))) { i.add(S); continue; } const w = o.nodeToNodeSubscriptions.get(S); if (w && fg(w, B => i.has(B))) { i.add(S); continue; } l.add(S), a.add(S); } const m = new Set; for (const S of a) for (const w of (_ = o.nodeDeps.get(S)) !== null && _ !== void 0 ? _ : jp) { var _; l.has(w) || m.add(w); } m.size && u(m); } } function mg(e, t, n, r, o) { const l = e.getGraph(t.version), i = [], u = new Set; for (; n.size > 0;)s(ve(n.values().next().value)); return i; function s(a) { if (r.has(a) || o.has(a)) { n.delete(a); return; } if (u.has(a)) return; const f = l.nodeToNodeSubscriptions.get(a); if (f) for (const p of f) s(p); u.add(a), n.delete(a), i.push(a); } } function yg(e, t, n) { if (!le("recoil_memory_managament_2020")) return; dg(e, n); const r = e.getState(); r.knownAtoms.delete(n), r.knownSelectors.delete(n), r.nodeTransactionSubscriptions.delete(n), r.retention.referenceCounts.delete(n); const o = Hp(n); for (const s of o) { var l; (l = r.retention.nodesRetainedByZone.get(s)) === null || l === void 0 || l.delete(n); } t.atomValues.delete(n), t.dirtyAtoms.delete(n), t.nonvalidatedAtoms.delete(n); const i = r.graphsByVersion.get(t.version); if (i) { const s = i.nodeDeps.get(n); if (s !== void 0) { i.nodeDeps.delete(n); for (const a of s) { var u; (u = i.nodeToNodeSubscriptions.get(a)) === null || u === void 0 || u.delete(n); } } i.nodeToNodeSubscriptions.delete(n); } pg(n); } function gg(e, t) { var n; return (n = e.retention.nodesRetainedByZone.get(t)) !== null && n !== void 0 ? n : jp; } function Hp(e) { const t = Fp(e).retainedBy; return t === void 0 || t === "components" || t === "recoilRoot" ? [] : t instanceof Bp ? [t] : t; } function Sg(e, t) { const n = e.getState(); n.nextTree ? n.retention.retainablesToCheckForRelease.add(t) : Wp(e, new Set([t])); } function _g(e, t, n) { var r; if (!le("recoil_memory_managament_2020")) return; const o = e.getState().retention.referenceCounts, l = ((r = o.get(t)) !== null && r !== void 0 ? r : 0) + n; l === 0 ? Kp(e, t) : o.set(t, l); } function Kp(e, t) { if (!le("recoil_memory_managament_2020")) return; e.getState().retention.referenceCounts.delete(t), Sg(e, t); } function wg(e) { if (!le("recoil_memory_managament_2020")) return; const t = e.getState(); Wp(e, t.retention.retainablesToCheckForRelease), t.retention.retainablesToCheckForRelease.clear(); } function Rg(e) { return e === void 0 ? "recoilRoot" : e; } var Pn = { SUSPENSE_TIMEOUT_MS: hg, updateRetainCount: _g, updateRetainCountToZero: Kp, releaseScheduledRetainablesNow: wg, retainedByOptionWithDefault: Rg }; const { unstable_batchedUpdates: Eg } = my; var Tg = { unstable_batchedUpdates: Eg }; const { unstable_batchedUpdates: kg } = Tg; var Ng = { unstable_batchedUpdates: kg }; const { batchStart: Cg } = Lt, { unstable_batchedUpdates: Lg } = Ng; let ua = Lg || (e => e()); const Ag = e => { ua = e; }, xg = () => ua, Pg = e => { ua(() => { let t = () => { }; try { t = Cg(), e(); } finally { t(); } }); }; var si = { getBatcher: xg, setBatcher: Ag, batchUpdates: Pg }; function* Mg(e) { for (const t of e) for (const n of t) yield n; } var Gp = Mg; const Qp = typeof Window > "u" || typeof window > "u", $g = e => !Qp && (e === window || e instanceof Window), Ig = typeof navigator < "u" && navigator.product === "ReactNative"; var ai = { isSSR: Qp, isReactNative: Ig, isWindow: $g }; function Vg(e, t) { let n; return (...r) => { n || (n = {}); const o = t(...r); return Object.hasOwnProperty.call(n, o) || (n[o] = e(...r)), n[o]; }; } function Dg(e, t) { let n, r; return (...o) => { const l = t(...o); return n === l || (n = l, r = e(...o)), r; }; } function zg(e, t) { let n, r; return [(...i) => { const u = t(...i); return n === u || (n = u, r = e(...i)), r; }, () => { n = null; }]; } var Ug = { memoizeWithArgsHash: Vg, memoizeOneWithArgsHash: Dg, memoizeOneWithArgsHashAndInvalidation: zg }; const { batchUpdates: Ju } = si, { initializeNode: Og, peekNodeInfo: Fg } = cn, { graph: Bg } = Ro, { getNextStoreID: jg } = li, { DEFAULT_VALUE: Wg, recoilValues: Mc, recoilValuesForKeys: $c } = Ze, { AbstractRecoilValue: Hg, getRecoilValueAsLoadable: Kg, setRecoilValue: Ic, setUnvalidatedRecoilValue: Gg } = Lt, { updateRetainCount: al } = Pn, { setInvalidateMemoizedSnapshot: Qg } = $p, { getNextTreeStateVersion: Yg, makeEmptyStoreState: Zg } = Np, { isSSR: bg } = ai, { memoizeOneWithArgsHashAndInvalidation: Xg } = Ug; class ci { constructor(t, n) { Y(this, "_store", void 0), Y(this, "_refCount", 1), Y(this, "getLoadable", r => (this.checkRefCount_INTERNAL(), Kg(this._store, r))), Y(this, "getPromise", r => (this.checkRefCount_INTERNAL(), this.getLoadable(r).toPromise())), Y(this, "getNodes_UNSTABLE", r => { if (this.checkRefCount_INTERNAL(), (r == null ? void 0 : r.isModified) === !0) { if ((r == null ? void 0 : r.isInitialized) === !1) return []; const i = this._store.getState().currentTree; return $c(i.dirtyAtoms); } const o = this._store.getState().knownAtoms, l = this._store.getState().knownSelectors; return (r == null ? void 0 : r.isInitialized) == null ? Mc.values() : r.isInitialized === !0 ? $c(Gp([o, l])) : oa(Mc.values(), ({ key: i }) => !o.has(i) && !l.has(i)); }), Y(this, "getInfo_UNSTABLE", ({ key: r }) => (this.checkRefCount_INTERNAL(), Fg(this._store, this._store.getState().currentTree, r))), Y(this, "map", r => { this.checkRefCount_INTERNAL(); const o = new qu(this, Ju); return r(o), o; }), Y(this, "asyncMap", async r => { this.checkRefCount_INTERNAL(); const o = new qu(this, Ju); return o.retain(), await r(o), o.autoRelease_INTERNAL(), o; }), this._store = { storeID: jg(), parentStoreID: n, getState: () => t, replaceState: r => { t.currentTree = r(t.currentTree); }, getGraph: r => { const o = t.graphsByVersion; if (o.has(r)) return ve(o.get(r)); const l = Bg(); return o.set(r, l), l; }, subscribeToTransactions: () => ({ release: () => { } }), addTransactionMetadata: () => { throw b("Cannot subscribe to Snapshots"); } }; for (const r of this._store.getState().knownAtoms) Og(this._store, r, "get"), al(this._store, r, 1); this.autoRelease_INTERNAL(); } retain() { this._refCount <= 0, this._refCount++; let t = !1; return () => { t || (t = !0, this._release()); }; } autoRelease_INTERNAL() { bg || window.setTimeout(() => this._release(), 10); } _release() { if (this._refCount--, this._refCount === 0) { if (this._store.getState().nodeCleanupFunctions.forEach(t => t()), this._store.getState().nodeCleanupFunctions.clear(), !le("recoil_memory_managament_2020")) return; } else this._refCount < 0; } isRetained() { return this._refCount > 0; } checkRefCount_INTERNAL() { le("recoil_memory_managament_2020") && this._refCount <= 0; } getStore_INTERNAL() { return this.checkRefCount_INTERNAL(), this._store; } getID() { return this.checkRefCount_INTERNAL(), this._store.getState().currentTree.stateID; } getStoreID() { return this.checkRefCount_INTERNAL(), this._store.storeID; } } function Yp(e, t, n = !1) { const r = e.getState(), o = n ? Yg() : t.version; return { currentTree: { version: n ? o : t.version, stateID: n ? o : t.stateID, transactionMetadata: { ...t.transactionMetadata }, dirtyAtoms: new Set(t.dirtyAtoms), atomValues: t.atomValues.clone(), nonvalidatedAtoms: t.nonvalidatedAtoms.clone() }, commitDepth: 0, nextTree: null, previousTree: null, knownAtoms: new Set(r.knownAtoms), knownSelectors: new Set(r.knownSelectors), transactionSubscriptions: new Map, nodeTransactionSubscriptions: new Map, nodeToComponentSubscriptions: new Map, queuedComponentCallbacks_DEPRECATED: [], suspendedComponentResolvers: new Set, graphsByVersion: new Map().set(o, e.getGraph(t.version)), retention: { referenceCounts: new Map, nodesRetainedByZone: new Map, retainablesToCheckForRelease: new Set }, nodeCleanupFunctions: new Map(oi(r.nodeCleanupFunctions.entries(), ([l]) => [l, () => { }])) }; } function Jg(e) { const t = new ci(Zg()); return e != null ? t.map(e) : t; } const [Vc, Zp] = Xg((e, t) => { var n; const r = e.getState(), o = t === "latest" ? (n = r.nextTree) !== null && n !== void 0 ? n : r.currentTree : ve(r.previousTree); return new ci(Yp(e, o), e.storeID); }, (e, t) => { var n, r; return String(t) + String(e.storeID) + String((n = e.getState().nextTree) === null || n === void 0 ? void 0 : n.version) + String(e.getState().currentTree.version) + String((r = e.getState().previousTree) === null || r === void 0 ? void 0 : r.version); }); Qg(Zp); function qg(e, t = "latest") { const n = Vc(e, t); return n.isRetained() ? n : (Zp(), Vc(e, t)); } class qu extends ci { constructor(t, n) { super(Yp(t.getStore_INTERNAL(), t.getStore_INTERNAL().getState().currentTree, !0), t.getStoreID()), Y(this, "_batch", void 0), Y(this, "set", (r, o) => { this.checkRefCount_INTERNAL(); const l = this.getStore_INTERNAL(); this._batch(() => { al(l, r.key, 1), Ic(this.getStore_INTERNAL(), r, o); }); }), Y(this, "reset", r => { this.checkRefCount_INTERNAL(); const o = this.getStore_INTERNAL(); this._batch(() => { al(o, r.key, 1), Ic(this.getStore_INTERNAL(), r, Wg); }); }), Y(this, "setUnvalidatedAtomValues_DEPRECATED", r => { this.checkRefCount_INTERNAL(); const o = this.getStore_INTERNAL(); Ju(() => { for (const [l, i] of r.entries()) al(o, l, 1), Gg(o, new Hg(l), i); }); }), this._batch = n; } } var fi = { Snapshot: ci, MutableSnapshot: qu, freshSnapshot: Jg, cloneSnapshot: qg }, eS = fi.Snapshot, tS = fi.MutableSnapshot, nS = fi.freshSnapshot, rS = fi.cloneSnapshot, di = Object.freeze({ __proto__: null, Snapshot: eS, MutableSnapshot: tS, freshSnapshot: nS, cloneSnapshot: rS }); function oS(...e) { const t = new Set; for (const n of e) for (const r of n) t.add(r); return t; } var lS = oS; const { useRef: iS } = ce; function uS(e) { const t = iS(e); return t.current === e && typeof e == "function" && (t.current = e()), t; } var Dc = uS; const { getNextTreeStateVersion: sS, makeEmptyStoreState: bp } = Np, { cleanUpNode: aS, getDownstreamNodes: cS, initializeNode: fS, setNodeValue: dS, setUnvalidatedAtomValue_DEPRECATED: pS } = cn, { graph: hS } = Ro, { cloneGraph: vS } = Ro, { getNextStoreID: Xp } = li, { createMutableSource: qi, reactMode: Jp } = wo, { applyAtomValueWrites: mS } = Lt, { releaseScheduledRetainablesNow: qp } = Pn, { freshSnapshot: yS } = di, { useCallback: gS, useContext: eh, useEffect: es, useMemo: SS, useRef: _S, useState: wS } = ce; function Lr() { throw b("This component must be used inside a <RecoilRoot> component."); } const th = Object.freeze({ storeID: Xp(), getState: Lr, replaceState: Lr, getGraph: Lr, subscribeToTransactions: Lr, addTransactionMetadata: Lr }); let ts = !1; function zc(e) { if (ts) throw b("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions."); const t = e.getState(); if (t.nextTree === null) { le("recoil_memory_managament_2020") && le("recoil_release_on_cascading_update_killswitch_2021") && t.commitDepth > 0 && qp(e); const n = t.currentTree.version, r = sS(); t.nextTree = { ...t.currentTree, version: r, stateID: r, dirtyAtoms: new Set, transactionMetadata: {} }, t.graphsByVersion.set(r, vS(ve(t.graphsByVersion.get(n)))); } } const nh = ce.createContext({ current: th }), pi = () => eh(nh), rh = ce.createContext(null); function RS() { return eh(rh); } function sa(e, t, n) { const r = cS(e, n, n.dirtyAtoms); for (const o of r) { const l = t.nodeToComponentSubscriptions.get(o); if (l) for (const [i, [u, s]] of l) s(n); } } function oh(e) { const t = e.getState(), n = t.currentTree, r = n.dirtyAtoms; if (r.size) { for (const [o, l] of t.nodeTransactionSubscriptions) if (r.has(o)) for (const [i, u] of l) u(e); for (const [o, l] of t.transactionSubscriptions) l(e); (!Jp().early || t.suspendedComponentResolvers.size > 0) && (sa(e, t, n), t.suspendedComponentResolvers.forEach(o => o()), t.suspendedComponentResolvers.clear()); } t.queuedComponentCallbacks_DEPRECATED.forEach(o => o(n)), t.queuedComponentCallbacks_DEPRECATED.splice(0, t.queuedComponentCallbacks_DEPRECATED.length); } function ES(e) { const t = e.getState(); t.commitDepth++; try { const { nextTree: n } = t; if (n == null) return; t.previousTree = t.currentTree, t.currentTree = n, t.nextTree = null, oh(e), t.previousTree != null ? t.graphsByVersion.delete(t.previousTree.version) : qs("Ended batch with no previous state, which is unexpected", "recoil"), t.previousTree = null, le("recoil_memory_managament_2020") && n == null && qp(e); } finally { t.commitDepth--; } } function TS({ setNotifyBatcherOfChange: e }) { const t = pi(), [, n] = wS([]); return e(() => n({})), es(() => (e(() => n({})), () => { e(() => { }); }), [e]), es(() => { n0.enqueueExecution("Batcher", () => { ES(t.current); }); }), null; } function kS(e, t) { const n = bp(); return t({ set: (r, o) => { const l = n.currentTree, i = dS(e, l, r.key, o), u = new Set(i.keys()), s = l.nonvalidatedAtoms.clone(); for (const a of u) s.delete(a); n.currentTree = { ...l, dirtyAtoms: lS(l.dirtyAtoms, u), atomValues: mS(l.atomValues, i), nonvalidatedAtoms: s }; }, setUnvalidatedAtomValues: r => { r.forEach((o, l) => { n.currentTree = pS(n.currentTree, l, o); }); } }), n; } function NS(e) { const t = yS(e), n = t.getStore_INTERNAL().getState(); return t.retain(), n.nodeCleanupFunctions.forEach(r => r()), n.nodeCleanupFunctions.clear(), n; } let Uc = 0; function CS({ initializeState_DEPRECATED: e, initializeState: t, store_INTERNAL: n, children: r }) { let o; const l = _ => { const S = o.current.graphsByVersion; if (S.has(_)) return ve(S.get(_)); const w = hS(); return S.set(_, w), w; }, i = (_, S) => { if (S == null) { const { transactionSubscriptions: w } = p.current.getState(), B = Uc++; return w.set(B, _), { release: () => { w.delete(B); } }; } else { const { nodeTransactionSubscriptions: w } = p.current.getState(); w.has(S) || w.set(S, new Map); const B = Uc++; return ve(w.get(S)).set(B, _), { release: () => { const h = w.get(S); h && (h.delete(B), h.size === 0 && w.delete(S)); } }; } }, u = _ => { zc(p.current); for (const S of Object.keys(_)) ve(p.current.getState().nextTree).transactionMetadata[S] = _[S]; }, s = _ => { zc(p.current); const S = ve(o.current.nextTree); let w; try { ts = !0, w = _(S); } finally { ts = !1; } w !== S && (o.current.nextTree = w, Jp().early && sa(p.current, o.current, w), ve(a.current)()); }, a = _S(null), f = gS(_ => { a.current = _; }, [a]), p = Dc(() => n ?? { storeID: Xp(), getState: () => o.current, replaceState: s, getGraph: l, subscribeToTransactions: i, addTransactionMetadata: u }); n != null && (p.current = n), o = Dc(() => e != null ? kS(p.current, e) : t != null ? NS(t) : bp()); const m = SS(() => qi == null ? void 0 : qi(o, () => o.current.currentTree.version), [o]); return es(() => { const _ = p.current; for (const S of new Set(_.getState().knownAtoms)) fS(_, S, "get"); return () => { for (const S of _.getState().knownAtoms) aS(_, S); }; }, [p]), ce.createElement(nh.Provider, { value: p }, ce.createElement(rh.Provider, { value: m }, ce.createElement(TS, { setNotifyBatcherOfChange: f }), r)); } function LS(e) { const { override: t, ...n } = e, r = pi(); return t === !1 && r.current !== th ? e.children : ce.createElement(CS, n); } function AS() { return pi().current.storeID; } var Bt = { RecoilRoot: LS, useStoreRef: pi, useRecoilMutableSource: RS, useRecoilStoreID: AS, notifyComponents_FOR_TESTING: sa, sendEndOfBatchNotifications_FOR_TESTING: oh }; function xS(e, t) { if (e === t) return !0; if (e.length !== t.length) return !1; for (let n = 0, r = e.length; n < r; n++)if (e[n] !== t[n]) return !1; return !0; } var PS = xS; const { useEffect: MS, useRef: $S } = ce; function IS(e) { const t = $S(); return MS(() => { t.current = e; }), t.current; } var lh = IS; const { useStoreRef: VS } = Bt, { SUSPENSE_TIMEOUT_MS: DS } = Pn, { updateRetainCount: Ar } = Pn, { RetentionZone: zS } = ii, { useEffect: US, useRef: OS } = ce, { isSSR: Oc } = ai; function FS(e) { if (le("recoil_memory_managament_2020")) return BS(e); } function BS(e) { const n = (Array.isArray(e) ? e : [e]).map(i => i instanceof zS ? i : i.key), r = VS(); US(() => { if (!le("recoil_memory_managament_2020")) return; const i = r.current; if (o.current && !Oc) window.clearTimeout(o.current), o.current = null; else for (const u of n) Ar(i, u, 1); return () => { for (const u of n) Ar(i, u, -1); }; }, [r, ...n]); const o = OS(), l = lh(n); if (!Oc && (l === void 0 || !PS(l, n))) { const i = r.current; for (const u of n) Ar(i, u, 1); if (l) for (const u of l) Ar(i, u, -1); o.current && window.clearTimeout(o.current), o.current = window.setTimeout(() => { o.current = null; for (const u of n) Ar(i, u, -1); }, DS); } } var aa = FS; function jS() { return "<component name not available>"; } var To = jS; const { batchUpdates: WS } = si, { DEFAULT_VALUE: ih } = Ze, { currentRendererSupportsUseSyncExternalStore: HS, reactMode: yr, useMutableSource: KS, useSyncExternalStore: GS } = wo, { useRecoilMutableSource: QS, useStoreRef: At } = Bt, { AbstractRecoilValue: ns, getRecoilValueAsLoadable: ko, setRecoilValue: Dl, setUnvalidatedRecoilValue: YS, subscribeToRecoilValue: cr } = Lt, { useCallback: Ye, useEffect: fr, useMemo: uh, useRef: Zr, useState: ca } = ce, { setByAddingToSet: ZS } = Lp, { isSSR: bS } = ai; function fa(e, t, n) { if (e.state === "hasValue") return e.contents; throw e.state === "loading" ? new Promise(o => { const l = n.current.getState().suspendedComponentResolvers; l.add(o), bS && se(e.contents) && e.contents.finally(() => { l.delete(o); }); }) : e.state === "hasError" ? e.contents : b(`Invalid value of loadable atom "${t.key}"`); } function XS() { const e = To(), t = At(), [, n] = ca([]), r = Zr(new Set); r.current = new Set; const o = Zr(new Set), l = Zr(new Map), i = Ye(s => { const a = l.current.get(s); a && (a.release(), l.current.delete(s)); }, [l]), u = Ye((s, a) => { l.current.has(a) && n([]); }, []); return fr(() => { const s = t.current; Qr(r.current, o.current).forEach(a => { if (l.current.has(a)) return; const f = cr(s, new ns(a), m => u(m, a), e); l.current.set(a, f), s.getState().nextTree ? s.getState().queuedComponentCallbacks_DEPRECATED.push(() => { u(s.getState(), a); }) : u(s.getState(), a); }), Qr(o.current, r.current).forEach(a => { i(a); }), o.current = r.current; }), fr(() => { const s = l.current; return Qr(r.current, new Set(s.keys())).forEach(a => { const f = cr(t.current, new ns(a), p => u(p, a), e); s.set(a, f); }), () => s.forEach((a, f) => i(f)); }, [e, t, i, u]), uh(() => { function s(S) { return w => { Dl(t.current, S, w); }; } function a(S) { return () => Dl(t.current, S, ih); } function f(S) { var w; r.current.has(S.key) || (r.current = ZS(r.current, S.key)); const B = t.current.getState(); return ko(t.current, S, yr().early && (w = B.nextTree) !== null && w !== void 0 ? w : B.currentTree); } function p(S) { const w = f(S); return fa(w, S, t); } function m(S) { return [p(S), s(S)]; } function _(S) { return [f(S), s(S)]; } return { getRecoilValue: p, getRecoilValueLoadable: f, getRecoilState: m, getRecoilStateLoadable: _, getSetRecoilState: s, getResetRecoilState: a }; }, [r, t]); } const JS = { current: 0 }; function qS(e) { const t = At(), n = To(), r = Ye(() => { var u; const s = t.current, a = s.getState(), f = yr().early && (u = a.nextTree) !== null && u !== void 0 ? u : a.currentTree; return { loadable: ko(s, e, f), key: e.key }; }, [t, e]), o = Ye(u => { let s; return () => { var a, f; const p = u(); return (a = s) !== null && a !== void 0 && a.loadable.is(p.loadable) && ((f = s) === null || f === void 0 ? void 0 : f.key) === p.key ? s : (s = p, p); }; }, []), l = uh(() => o(r), [r, o]), i = Ye(u => { const s = t.current; return cr(s, e, u, n).release; }, [t, e, n]); return GS(i, l, l).loadable; } function e1(e) { const t = At(), n = Ye(() => { var a; const f = t.current, p = f.getState(), m = yr().early && (a = p.nextTree) !== null && a !== void 0 ? a : p.currentTree; return ko(f, e, m); }, [t, e]), r = Ye(() => n(), [n]), o = To(), l = Ye((a, f) => { const p = t.current; return cr(p, e, () => { if (!le("recoil_suppress_rerender_in_callback")) return f(); const _ = n(); s.current.is(_) || f(), s.current = _; }, o).release; }, [t, e, o, n]), i = QS(); if (i == null) throw b("Recoil hooks must be used in components contained within a <RecoilRoot> component."); const u = KS(i, r, l), s = Zr(u); return fr(() => { s.current = u; }), u; } function rs(e) { const t = At(), n = To(), r = Ye(() => { var s; const a = t.current, f = a.getState(), p = yr().early && (s = f.nextTree) !== null && s !== void 0 ? s : f.currentTree; return ko(a, e, p); }, [t, e]), o = Ye(() => ({ loadable: r(), key: e.key }), [r, e.key]), l = Ye(s => { const a = o(); return s.loadable.is(a.loadable) && s.key === a.key ? s : a; }, [o]); fr(() => { const s = cr(t.current, e, a => { u(l); }, n); return u(l), s.release; }, [n, e, t, l]); const [i, u] = ca(o); return i.key !== e.key ? o().loadable : i.loadable; } function t1(e) { const t = At(), [, n] = ca([]), r = To(), o = Ye(() => { var u; const s = t.current, a = s.getState(), f = yr().early && (u = a.nextTree) !== null && u !== void 0 ? u : a.currentTree; return ko(s, e, f); }, [t, e]), l = o(), i = Zr(l); return fr(() => { i.current = l; }), fr(() => { const u = t.current, s = u.getState(), a = cr(u, e, p => { var m; if (!le("recoil_suppress_rerender_in_callback")) return n([]); const _ = o(); (m = i.current) !== null && m !== void 0 && m.is(_) || n(_), i.current = _; }, r); if (s.nextTree) u.getState().queuedComponentCallbacks_DEPRECATED.push(() => { i.current = null, n([]); }); else { var f; if (!le("recoil_suppress_rerender_in_callback")) return n([]); const p = o(); (f = i.current) !== null && f !== void 0 && f.is(p) || n(p), i.current = p; } return a.release; }, [r, o, e, t]), l; } function da(e) { return le("recoil_memory_managament_2020") && aa(e), { TRANSITION_SUPPORT: rs, SYNC_EXTERNAL_STORE: HS() ? qS : rs, MUTABLE_SOURCE: e1, LEGACY: t1 }[yr().mode](e); } function sh(e) { const t = At(), n = da(e); return fa(n, e, t); } function hi(e) { const t = At(); return Ye(n => { Dl(t.current, e, n); }, [t, e]); } function n1(e) { const t = At(); return Ye(() => { Dl(t.current, e, ih); }, [t, e]); } function r1(e) { return [sh(e), hi(e)]; } function o1(e) { return [da(e), hi(e)]; } function l1() { const e = At(); return (t, n = {}) => { WS(() => { e.current.addTransactionMetadata(n), t.forEach((r, o) => YS(e.current, new ns(o), r)); }); }; } function ah(e) { return le("recoil_memory_managament_2020") && aa(e), rs(e); } function ch(e) { const t = At(), n = ah(e); return fa(n, e, t); } function i1(e) { return [ch(e), hi(e)]; } var u1 = { recoilComponentGetRecoilValueCount_FOR_TESTING: JS, useRecoilInterface: XS, useRecoilState: r1, useRecoilStateLoadable: o1, useRecoilValue: sh, useRecoilValueLoadable: da, useResetRecoilState: n1, useSetRecoilState: hi, useSetUnvalidatedAtomValues: l1, useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: ah, useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: ch, useRecoilState_TRANSITION_SUPPORT_UNSTABLE: i1 }; function s1(e, t) { const n = new Map; for (const [r, o] of e) t(o, r) && n.set(r, o); return n; } var a1 = s1; function c1(e, t) { const n = new Set; for (const r of e) t(r) && n.add(r); return n; } var f1 = c1; function d1(...e) { const t = new Map; for (let n = 0; n < e.length; n++) { const r = e[n].keys(); let o; for (; !(o = r.next()).done;)t.set(o.value, e[n].get(o.value)); } return t; } var p1 = d1; const { batchUpdates: h1 } = si, { DEFAULT_VALUE: v1, getNode: fh, nodes: m1 } = Ze, { useStoreRef: pa } = Bt, { AbstractRecoilValue: y1, setRecoilValueLoadable: g1 } = Lt, { SUSPENSE_TIMEOUT_MS: S1 } = Pn, { cloneSnapshot: zl } = di, { useCallback: vi, useEffect: dh, useRef: Fc, useState: _1 } = ce, { isSSR: Bc } = ai; function mi(e) { const t = pa(); dh(() => t.current.subscribeToTransactions(e).release, [e, t]); } function jc(e) { const t = e.atomValues.toMap(), n = Vl(a1(t, (r, o) => { const i = fh(o).persistence_UNSTABLE; return i != null && i.type !== "none" && r.state === "hasValue"; }), r => r.contents); return p1(e.nonvalidatedAtoms.toMap(), n); } function w1(e) { mi(vi(t => { let n = t.getState().previousTree; const r = t.getState().currentTree; n || (n = t.getState().currentTree); const o = jc(r), l = jc(n), i = Vl(m1, s => { var a, f, p, m; return { persistence_UNSTABLE: { type: (a = (f = s.persistence_UNSTABLE) === null || f === void 0 ? void 0 : f.type) !== null && a !== void 0 ? a : "none", backButton: (p = (m = s.persistence_UNSTABLE) === null || m === void 0 ? void 0 : m.backButton) !== null && p !== void 0 ? p : !1 } }; }), u = f1(r.dirtyAtoms, s => o.has(s) || l.has(s)); e({ atomValues: o, previousAtomValues: l, atomInfo: i, modifiedAtoms: u, transactionMetadata: { ...r.transactionMetadata } }); }, [e])); } function R1(e) { mi(vi(t => { const n = zl(t, "latest"), r = zl(t, "previous"); e({ snapshot: n, previousSnapshot: r }); }, [e])); } function E1() { const e = pa(), [t, n] = _1(() => zl(e.current)), r = lh(t), o = Fc(), l = Fc(); if (mi(vi(u => n(zl(u)), [])), dh(() => { const u = t.retain(); if (o.current && !Bc) { var s; window.clearTimeout(o.current), o.current = null, (s = l.current) === null || s === void 0 || s.call(l), l.current = null; } return () => { window.setTimeout(u, 10); }; }, [t]), r !== t && !Bc) { if (o.current) { var i; window.clearTimeout(o.current), o.current = null, (i = l.current) === null || i === void 0 || i.call(l), l.current = null; } l.current = t.retain(), o.current = window.setTimeout(() => { var u; o.current = null, (u = l.current) === null || u === void 0 || u.call(l), l.current = null; }, S1); } return t; } function ph(e, t) { var n; const r = e.getState(), o = (n = r.nextTree) !== null && n !== void 0 ? n : r.currentTree, l = t.getStore_INTERNAL().getState().currentTree; h1(() => { const i = new Set; for (const a of [o.atomValues.keys(), l.atomValues.keys()]) for (const f of a) { var u, s; ((u = o.atomValues.get(f)) === null || u === void 0 ? void 0 : u.contents) !== ((s = l.atomValues.get(f)) === null || s === void 0 ? void 0 : s.contents) && fh(f).shouldRestoreFromSnapshots && i.add(f); } i.forEach(a => { g1(e, new y1(a), l.atomValues.has(a) ? ve(l.atomValues.get(a)) : v1); }), e.replaceState(a => ({ ...a, stateID: t.getID() })); }); } function T1() { const e = pa(); return vi(t => ph(e.current, t), [e]); } var hh = { useRecoilSnapshot: E1, gotoSnapshot: ph, useGotoRecoilSnapshot: T1, useRecoilTransactionObserver: R1, useTransactionObservation_DEPRECATED: w1, useTransactionSubscription_DEPRECATED: mi }; const { peekNodeInfo: k1 } = cn, { useStoreRef: N1 } = Bt; function C1() { const e = N1(); return ({ key: t }) => k1(e.current, e.current.getState().currentTree, t); } var L1 = C1; const { reactMode: A1 } = wo, { RecoilRoot: x1, useStoreRef: P1 } = Bt, { useMemo: M1 } = ce; function $1() { A1().mode === "MUTABLE_SOURCE" && console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode."); const e = P1().current; return M1(() => { function t({ children: n }) { return ce.createElement(x1, { store_INTERNAL: e }, n); } return t; }, [e]); } var I1 = $1; const { loadableWithValue: V1 } = _o, { initializeNode: D1 } = cn, { DEFAULT_VALUE: z1, getNode: U1 } = Ze, { copyTreeState: O1, getRecoilValueAsLoadable: F1, invalidateDownstreams: B1, writeLoadableToTreeState: j1 } = Lt; function Wc(e) { return U1(e.key).nodeType === "atom"; } class W1 { constructor(t, n) { Y(this, "_store", void 0), Y(this, "_treeState", void 0), Y(this, "_changes", void 0), Y(this, "get", r => { if (this._changes.has(r.key)) return this._changes.get(r.key); if (!Wc(r)) throw b("Reading selectors within atomicUpdate is not supported"); const o = F1(this._store, r, this._treeState); if (o.state === "hasValue") return o.contents; throw o.state === "hasError" ? o.contents : b(`Expected Recoil atom ${r.key} to have a value, but it is in a loading state.`); }), Y(this, "set", (r, o) => { if (!Wc(r)) throw b("Setting selectors within atomicUpdate is not supported"); if (typeof o == "function") { const l = this.get(r); this._changes.set(r.key, o(l)); } else D1(this._store, r.key, "set"), this._changes.set(r.key, o); }), Y(this, "reset", r => { this.set(r, z1); }), this._store = t, this._treeState = n, this._changes = new Map; } newTreeState_INTERNAL() { if (this._changes.size === 0) return this._treeState; const t = O1(this._treeState); for (const [n, r] of this._changes) j1(t, n, V1(r)); return B1(this._store, t), t; } } function H1(e) { return t => { e.replaceState(n => { const r = new W1(e, n); return t(r), r.newTreeState_INTERNAL(); }); }; } var K1 = { atomicUpdater: H1 }, G1 = K1.atomicUpdater, vh = Object.freeze({ __proto__: null, atomicUpdater: G1 }); function Q1(e, t) { if (!e) throw new Error(t); } var Y1 = Q1, zr = Y1; const { atomicUpdater: Z1 } = vh, { batchUpdates: b1 } = si, { DEFAULT_VALUE: X1 } = Ze, { useStoreRef: J1 } = Bt, { refreshRecoilValue: q1, setRecoilValue: Hc } = Lt, { cloneSnapshot: e_ } = di, { gotoSnapshot: t_ } = hh, { useCallback: n_ } = ce; class mh { } const r_ = new mh; function yh(e, t, n, r) { let o = r_, l; if (b1(() => { const u = "useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details."; if (typeof t != "function") throw b(u); const s = Ap({ ...r ?? {}, set: (f, p) => Hc(e, f, p), reset: f => Hc(e, f, X1), refresh: f => q1(e, f), gotoSnapshot: f => t_(e, f), transact_UNSTABLE: f => Z1(e)(f) }, { snapshot: () => { const f = e_(e); return l = f.retain(), f; } }), a = t(s); if (typeof a != "function") throw b(u); o = a(...n); }), o instanceof mh && zr(!1), se(o)) o = o.finally(() => { var u; (u = l) === null || u === void 0 || u(); }); else { var i; (i = l) === null || i === void 0 || i(); } return o; } function o_(e, t) { const n = J1(); return n_((...r) => yh(n.current, e, r), t != null ? [...t, n] : void 0); } var gh = { recoilCallback: yh, useRecoilCallback: o_ }; const { useStoreRef: l_ } = Bt, { refreshRecoilValue: i_ } = Lt, { useCallback: u_ } = ce; function s_(e) { const t = l_(); return u_(() => { const n = t.current; i_(n, e); }, [e, t]); } var a_ = s_; const { atomicUpdater: c_ } = vh, { useStoreRef: f_ } = Bt, { useMemo: d_ } = ce; function p_(e, t) { const n = f_(); return d_(() => (...r) => { c_(n.current)(l => { e(l)(...r); }); }, t != null ? [...t, n] : void 0); } var h_ = p_; class v_ { constructor(t) { Y(this, "value", void 0), this.value = t; } } var m_ = { WrappedValue: v_ }, y_ = m_.WrappedValue, Sh = Object.freeze({ __proto__: null, WrappedValue: y_ }); const { isFastRefreshEnabled: g_ } = wo; class Kc extends Error { } class S_ { constructor(t) { var n, r, o; Y(this, "_name", void 0), Y(this, "_numLeafs", void 0), Y(this, "_root", void 0), Y(this, "_onHit", void 0), Y(this, "_onSet", void 0), Y(this, "_mapNodeValue", void 0), this._name = t == null ? void 0 : t.name, this._numLeafs = 0, this._root = null, this._onHit = (n = t == null ? void 0 : t.onHit) !== null && n !== void 0 ? n : () => { }, this._onSet = (r = t == null ? void 0 : t.onSet) !== null && r !== void 0 ? r : () => { }, this._mapNodeValue = (o = t == null ? void 0 : t.mapNodeValue) !== null && o !== void 0 ? o : l => l; } size() { return this._numLeafs; } root() { return this._root; } get(t, n) { var r; return (r = this.getLeafNode(t, n)) === null || r === void 0 ? void 0 : r.value; } getLeafNode(t, n) { if (this._root == null) return; let r = this._root; for (; r;) { if (n == null || n.onNodeVisit(r), r.type === "leaf") return this._onHit(r), r; const o = this._mapNodeValue(t(r.nodeKey)); r = r.branches.get(o); } } set(t, n, r) { const o = () => { var l, i, u, s; let a, f; for (const [B, h] of t) { var p, m, _; const c = this._root; if ((c == null ? void 0 : c.type) === "leaf") throw this.invalidCacheError(); const d = a; if (a = d ? d.branches.get(f) : c, a = (p = a) !== null && p !== void 0 ? p : { type: "branch", nodeKey: B, parent: d, branches: new Map, branchKey: f }, a.type !== "branch" || a.nodeKey !== B) throw this.invalidCacheError(); d == null || d.branches.set(f, a), r == null || (m = r.onNodeVisit) === null || m === void 0 || m.call(r, a), f = this._mapNodeValue(h), this._root = (_ = this._root) !== null && _ !== void 0 ? _ : a; } const S = a ? (l = a) === null || l === void 0 ? void 0 : l.branches.get(f) : this._root; if (S != null && (S.type !== "leaf" || S.branchKey !== f)) throw this.invalidCacheError(); const w = { type: "leaf", value: n, parent: a, branchKey: f }; (i = a) === null || i === void 0 || i.branches.set(f, w), this._root = (u = this._root) !== null && u !== void 0 ? u : w, this._numLeafs++, this._onSet(w), r == null || (s = r.onNodeVisit) === null || s === void 0 || s.call(r, w); }; try { o(); } catch (l) { if (l instanceof Kc) this.clear(), o(); else throw l; } } delete(t) { const n = this.root(); if (!n) return !1; if (t === n) return this._root = null, this._numLeafs = 0, !0; let r = t.parent, o = t.branchKey; for (; r;) { var l; if (r.branches.delete(o), r === n) return r.branches.size === 0 ? (this._root = null, this._numLeafs = 0) : this._numLeafs--, !0; if (r.branches.size > 0) break; o = (l = r) === null || l === void 0 ? void 0 : l.branchKey, r = r.parent; } for (; r !== n; r = r.parent)if (r == null) return !1; return this._numLeafs--, !0; } clear() { this._numLeafs = 0, this._root = null; } invalidCacheError() { const t = g_() ? "Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache." : "Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache."; throw qs(t + (this._name != null ? ` - ${this._name}` : "")), new Kc; } } var __ = { TreeCache: S_ }, w_ = __.TreeCache, _h = Object.freeze({ __proto__: null, TreeCache: w_ }); class R_ { constructor(t) { var n; Y(this, "_maxSize", void 0), Y(this, "_size", void 0), Y(this, "_head", void 0), Y(this, "_tail", void 0), Y(this, "_map", void 0), Y(this, "_keyMapper", void 0), this._maxSize = t.maxSize, this._size = 0, this._head = null, this._tail = null, this._map = new Map, this._keyMapper = (n = t.mapKey) !== null && n !== void 0 ? n : r => r; } head() { return this._head; } tail() { return this._tail; } size() { return this._size; } maxSize() { return this._maxSize; } has(t) { return this._map.has(this._keyMapper(t)); } get(t) { const n = this._keyMapper(t), r = this._map.get(n); if (r) return this.set(t, r.value), r.value; } set(t, n) { const r = this._keyMapper(t); this._map.get(r) && this.delete(t); const l = this.head(), i = { key: t, right: l, left: null, value: n }; l ? l.left = i : this._tail = i, this._map.set(r, i), this._head = i, this._size++, this._maybeDeleteLRU(); } _maybeDeleteLRU() { this.size() > this.maxSize() && this.deleteLru(); } deleteLru() { const t = this.tail(); t && this.delete(t.key); } delete(t) { const n = this._keyMapper(t); if (!this._size || !this._map.has(n)) return; const r = ve(this._map.get(n)), o = r.right, l = r.left; o && (o.left = r.left), l && (l.right = r.right), r === this.head() && (this._head = o), r === this.tail() && (this._tail = l), this._map.delete(n), this._size--; } clear() { this._size = 0, this._head = null, this._tail = null, this._map = new Map; } } var E_ = { LRUCache: R_ }, T_ = E_.LRUCache, wh = Object.freeze({ __proto__: null, LRUCache: T_ }); const { LRUCache: k_ } = wh, { TreeCache: N_ } = _h; function C_({ name: e, maxSize: t, mapNodeValue: n = r => r }) { const r = new k_({ maxSize: t }), o = new N_({ name: e, mapNodeValue: n, onHit: l => { r.set(l, !0); }, onSet: l => { const i = r.tail(); r.set(l, !0), i && o.size() > t && o.delete(i.key); } }); return o; } var Gc = C_; function mt(e, t, n) { if (typeof e == "string" && !e.includes('"') && !e.includes("\\")) return `"${e}"`; switch (typeof e) { case "undefined": return ""; case "boolean": return e ? "true" : "false"; case "number": case "symbol": return String(e); case "string": return JSON.stringify(e); case "function": if ((t == null ? void 0 : t.allowFunctions) !== !0) throw b("Attempt to serialize function in a Recoil cache key"); return `__FUNCTION(${e.name})__`; }if (e === null) return "null"; if (typeof e != "object") { var r; return (r = JSON.stringify(e)) !== null && r !== void 0 ? r : ""; } if (se(e)) return "__PROMISE__"; if (Array.isArray(e)) return `[${e.map((o, l) => mt(o, t, l.toString()))}]`; if (typeof e.toJSON == "function") return mt(e.toJSON(n), t, n); if (e instanceof Map) { const o = {}; for (const [l, i] of e) o[typeof l == "string" ? l : mt(l, t)] = i; return mt(o, t, n); } return e instanceof Set ? mt(Array.from(e).sort((o, l) => mt(o, t).localeCompare(mt(l, t))), t, n) : Symbol !== void 0 && e[Symbol.iterator] != null && typeof e[Symbol.iterator] == "function" ? mt(Array.from(e), t, n) : `{${Object.keys(e).filter(o => e[o] !== void 0).sort().map(o => `${mt(o, t)}:${mt(e[o], t, o)}`).join(",")}}`; } function L_(e, t = { allowFunctions: !1 }) { return mt(e, t); } var yi = L_; const { TreeCache: A_ } = _h, Go = { equality: "reference", eviction: "keep-all", maxSize: 1 / 0 }; function x_({ equality: e = Go.equality, eviction: t = Go.eviction, maxSize: n = Go.maxSize } = Go, r) { const o = P_(e); return M_(t, n, o, r); } function P_(e) { switch (e) { case "reference": return t => t; case "value": return t => yi(t); }throw b(`Unrecognized equality policy ${e}`); } function M_(e, t, n, r) { switch (e) { case "keep-all": return new A_({ name: r, mapNodeValue: n }); case "lru": return Gc({ name: r, maxSize: ve(t), mapNodeValue: n }); case "most-recent": return Gc({ name: r, maxSize: 1, mapNodeValue: n }); }throw b(`Unrecognized eviction policy ${e}`); } var $_ = x_; function I_(e) { return () => null; } var V_ = { startPerfBlock: I_ }; const { isLoadable: D_, loadableWithError: Qo, loadableWithPromise: z_, loadableWithValue: eu } = _o, { WrappedValue: Rh } = Sh, { getNodeLoadable: Yo, peekNodeLoadable: U_, setNodeValue: O_ } = cn, { saveDepsToStore: F_ } = Ro, { DEFAULT_VALUE: B_, getConfigDeletionHandler: j_, getNode: W_, registerNode: Qc } = Ze, { isRecoilValue: H_ } = ar, { markRecoilValueModified: Yc } = Lt, { retainedByOptionWithDefault: K_ } = Pn, { recoilCallback: G_ } = gh, { startPerfBlock: Q_ } = V_; class Eh { } const xr = new Eh, Pr = [], Zo = new Map, Y_ = (() => { let e = 0; return () => e++; })(); function Th(e) { let t = null; const { key: n, get: r, cachePolicy_UNSTABLE: o } = e, l = e.set != null ? e.set : void 0, i = new Set, u = $_(o ?? { equality: "reference", eviction: "keep-all" }, n), s = K_(e.retainedBy_UNSTABLE), a = new Map; let f = 0; function p() { return !le("recoil_memory_managament_2020") || f > 0; } function m(y) { return y.getState().knownSelectors.add(n), f++, () => { f--; }; } function _() { return j_(n) !== void 0 && !p(); } function S(y, N, A, K, V) { $e(N, K, V), w(y, A); } function w(y, N) { Me(y, N) && re(y), h(N, !0); } function B(y, N) { Me(y, N) && (ve(U(y)).stateVersions.clear(), h(N, !1)); } function h(y, N) { const A = Zo.get(y); if (A != null) { for (const K of A) Yc(K, ve(t)); N && Zo.delete(y); } } function c(y, N) { let A = Zo.get(N); A == null && Zo.set(N, A = new Set), A.add(y); } function d(y, N, A, K, V, Z) { return N.then(J => { if (!p()) throw re(y), xr; const F = eu(J); return S(y, A, V, F, K), J; }).catch(J => { if (!p()) throw re(y), xr; if (se(J)) return R(y, J, A, K, V, Z); const F = Qo(J); throw S(y, A, V, F, K), J; }); } function R(y, N, A, K, V, Z) { return N.then(J => { if (!p()) throw re(y), xr; Z.loadingDepKey != null && Z.loadingDepPromise === N ? A.atomValues.set(Z.loadingDepKey, eu(J)) : y.getState().knownSelectors.forEach(oe => { A.atomValues.delete(oe); }); const F = L(y, A); if (F && F.state !== "loading") { if ((Me(y, V) || U(y) == null) && w(y, V), F.state === "hasValue") return F.contents; throw F.contents; } if (!Me(y, V)) { const oe = te(y, A); if (oe != null) return oe.loadingLoadable.contents; } const [de, Ee] = C(y, A, V); if (de.state !== "loading" && S(y, A, V, de, Ee), de.state === "hasError") throw de.contents; return de.contents; }).catch(J => { if (J instanceof Eh) throw xr; if (!p()) throw re(y), xr; const F = Qo(J); throw S(y, A, V, F, K), J; }); } function k(y, N, A, K) { var V, Z, J, F; if (Me(y, K) || N.version === ((V = y.getState()) === null || V === void 0 || (Z = V.currentTree) === null || Z === void 0 ? void 0 : Z.version) || N.version === ((J = y.getState()) === null || J === void 0 || (F = J.nextTree) === null || F === void 0 ? void 0 : F.version)) { var de, Ee, oe; F_(n, A, y, (de = (Ee = y.getState()) === null || Ee === void 0 || (oe = Ee.nextTree) === null || oe === void 0 ? void 0 : oe.version) !== null && de !== void 0 ? de : y.getState().currentTree.version); } for (const me of A) i.add(me); } function C(y, N, A) { const K = Q_(n); let V = !0, Z = !0; const J = () => { K(), Z = !1; }; let F, de = !1, Ee; const oe = { loadingDepKey: null, loadingDepPromise: null }, me = new Map; function pt({ key: lt }) { const Xe = Yo(y, N, lt); switch (me.set(lt, Xe), V || (k(y, N, new Set(me.keys()), A), B(y, A)), Xe.state) { case "hasValue": return Xe.contents; case "hasError": throw Xe.contents; case "loading": throw oe.loadingDepKey = lt, oe.loadingDepPromise = Xe.contents, Xe.contents; }throw b("Invalid Loadable state"); } const dn = lt => (...Xe) => { if (Z) throw b("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription."); return t == null && zr(!1), G_(y, lt, Xe, { node: t }); }; try { F = r({ get: pt, getCallback: dn }), F = H_(F) ? pt(F) : F, D_(F) && (F.state === "hasError" && (de = !0), F = F.contents), se(F) ? F = d(y, F, N, me, A, oe).finally(J) : J(), F = F instanceof Rh ? F.value : F; } catch (lt) { F = lt, se(F) ? F = R(y, F, N, me, A, oe).finally(J) : (de = !0, J()); } return de ? Ee = Qo(F) : se(F) ? Ee = z_(F) : Ee = eu(F), V = !1, ot(y, A, me), k(y, N, new Set(me.keys()), A), [Ee, me]; } function L(y, N) { let A = N.atomValues.get(n); if (A != null) return A; const K = new Set; try { A = u.get(Z => (typeof Z != "string" && zr(!1), Yo(y, N, Z).contents), { onNodeVisit: Z => { Z.type === "branch" && Z.nodeKey !== n && K.add(Z.nodeKey); } }); } catch (Z) { throw b(`Problem with cache lookup for selector "${n}": ${Z.message}`); } if (A) { var V; N.atomValues.set(n, A), k(y, N, K, (V = U(y)) === null || V === void 0 ? void 0 : V.executionID); } return A; } function I(y, N) { const A = L(y, N); if (A != null) return re(y), A; const K = te(y, N); if (K != null) { var V; return ((V = K.loadingLoadable) === null || V === void 0 ? void 0 : V.state) === "loading" && c(y, K.executionID), K.loadingLoadable; } const Z = Y_(), [J, F] = C(y, N, Z); return J.state === "loading" ? (fe(y, Z, J, F, N), c(y, Z)) : (re(y), $e(N, J, F)), J; } function te(y, N) { const A = Gp([a.has(y) ? [ve(a.get(y))] : [], oi(oa(a, ([V]) => V !== y), ([, V]) => V)]); function K(V) { for (const [Z, J] of V) if (!Yo(y, N, Z).is(J)) return !0; return !1; } for (const V of A) { if (V.stateVersions.get(N.version) || !K(V.depValuesDiscoveredSoFarDuringAsyncWork)) return V.stateVersions.set(N.version, !0), V; V.stateVersions.set(N.version, !1); } } function U(y) { return a.get(y); } function fe(y, N, A, K, V) { a.set(y, { depValuesDiscoveredSoFarDuringAsyncWork: K, executionID: N, loadingLoadable: A, stateVersions: new Map([[V.version, !0]]) }); } function ot(y, N, A) { if (Me(y, N)) { const K = U(y); K != null && (K.depValuesDiscoveredSoFarDuringAsyncWork = A); } } function re(y) { a.delete(y); } function Me(y, N) { var A; return N === ((A = U(y)) === null || A === void 0 ? void 0 : A.executionID); } function xt(y) { return Array.from(y.entries()).map(([N, A]) => [N, A.contents]); } function $e(y, N, A) { y.atomValues.set(n, N); try { u.set(xt(A), N); } catch (K) { throw b(`Problem with setting cache for selector "${n}": ${K.message}`); } } function be(y) { if (Pr.includes(n)) { const N = `Recoil selector has circular dependencies: ${Pr.slice(Pr.indexOf(n)).join(" → ")}`; return Qo(b(N)); } Pr.push(n); try { return y(); } finally { Pr.pop(); } } function M(y, N) { const A = N.atomValues.get(n); return A ?? u.get(K => { var V; return typeof K != "string" && zr(!1), (V = U_(y, N, K)) === null || V === void 0 ? void 0 : V.contents; }); } function j(y, N) { return be(() => I(y, N)); } function $(y) { y.atomValues.delete(n); } function O(y, N) { t == null && zr(!1); for (const K of i) { var A; const V = W_(K); (A = V.clearCache) === null || A === void 0 || A.call(V, y, N); } i.clear(), $(N), u.clear(), Yc(y, t); } return l != null ? t = Qc({ key: n, nodeType: "selector", peek: M, get: j, set: (N, A, K) => { let V = !1; const Z = new Map; function J({ key: oe }) { if (V) throw b("Recoil: Async selector sets are not currently supported."); const me = Yo(N, A, oe); if (me.state === "hasValue") return me.contents; if (me.state === "loading") { const pt = `Getting value of asynchronous atom or selector "${oe}" in a pending state while setting selector "${n}" is not yet supported.`; throw b(pt); } else throw me.contents; } function F(oe, me) { if (V) throw b("Recoil: Async selector sets are not currently supported."); const pt = typeof me == "function" ? me(J(oe)) : me; O_(N, A, oe.key, pt).forEach((lt, Xe) => Z.set(Xe, lt)); } function de(oe) { F(oe, B_); } const Ee = l({ set: F, get: J, reset: de }, K); if (Ee !== void 0) throw se(Ee) ? b("Recoil: Async selector sets are not currently supported.") : b("Recoil: selector set should be a void function."); return V = !0, Z; }, init: m, invalidate: $, clearCache: O, shouldDeleteConfigOnRelease: _, dangerouslyAllowMutability: e.dangerouslyAllowMutability, shouldRestoreFromSnapshots: !1, retainedBy: s }) : t = Qc({ key: n, nodeType: "selector", peek: M, get: j, init: m, invalidate: $, clearCache: O, shouldDeleteConfigOnRelease: _, dangerouslyAllowMutability: e.dangerouslyAllowMutability, shouldRestoreFromSnapshots: !1, retainedBy: s }); } Th.value = e => new Rh(e); var dr = Th; const { isLoadable: Z_, loadableWithError: tu, loadableWithPromise: nu, loadableWithValue: In } = _o, { WrappedValue: kh } = Sh, { peekNodeInfo: b_ } = cn, { DEFAULT_VALUE: vn, DefaultValue: Kt, getConfigDeletionHandler: Nh, registerNode: X_, setConfigDeletionHandler: J_ } = Ze, { isRecoilValue: q_ } = ar, { getRecoilValueAsLoadable: ew, markRecoilValueModified: tw, setRecoilValue: Zc, setRecoilValueLoadable: nw } = Lt, { retainedByOptionWithDefault: rw } = Pn, Mr = e => e instanceof kh ? e.value : e; function ow(e) { const { key: t, persistence_UNSTABLE: n } = e, r = rw(e.retainedBy_UNSTABLE); let o = 0; function l(c) { return nu(c.then(d => (i = In(d), d)).catch(d => { throw i = tu(d), d; })); } let i = se(e.default) ? l(e.default) : Z_(e.default) ? e.default.state === "loading" ? l(e.default.contents) : e.default : In(Mr(e.default)); i.contents; let u; const s = new Map; function a(c) { return c; } function f(c, d) { const R = d.then(k => { var C, L; return ((L = ((C = c.getState().nextTree) !== null && C !== void 0 ? C : c.getState().currentTree).atomValues.get(t)) === null || L === void 0 ? void 0 : L.contents) === R && Zc(c, h, k), k; }).catch(k => { var C, L; throw ((L = ((C = c.getState().nextTree) !== null && C !== void 0 ? C : c.getState().currentTree).atomValues.get(t)) === null || L === void 0 ? void 0 : L.contents) === R && nw(c, h, tu(k)), k; }); return R; } function p(c, d, R) { var k; o++; const C = () => { var U; o--, (U = s.get(c)) === null || U === void 0 || U.forEach(fe => fe()), s.delete(c); }; if (c.getState().knownAtoms.add(t), i.state === "loading") { const U = () => { var fe; ((fe = c.getState().nextTree) !== null && fe !== void 0 ? fe : c.getState().currentTree).atomValues.has(t) || tw(c, h); }; i.contents.finally(U); } const L = (k = e.effects) !== null && k !== void 0 ? k : e.effects_UNSTABLE; if (L != null) { let U = function ($) { if (Me && $.key === t) { const O = re; return O instanceof Kt ? m(c, d) : se(O) ? nu(O.then(y => y instanceof Kt ? i.toPromise() : y)) : In(O); } return ew(c, $); }, fe = function ($) { return U($).toPromise(); }, ot = function ($) { var O; const y = b_(c, (O = c.getState().nextTree) !== null && O !== void 0 ? O : c.getState().currentTree, $.key); return Me && $.key === t && !(re instanceof Kt) ? { ...y, isSet: !0, loadable: U($) } : y; }, re = vn, Me = !0, xt = !1, $e = null; const be = $ => O => { if (Me) { const y = U(h), N = y.state === "hasValue" ? y.contents : vn; re = typeof O == "function" ? O(N) : O, se(re) && (re = re.then(A => ($e = { effect: $, value: A }, A))); } else { if (se(O)) throw b("Setting atoms to async values is not implemented."); typeof O != "function" && ($e = { effect: $, value: Mr(O) }), Zc(c, h, typeof O == "function" ? y => { const N = Mr(O(y)); return $e = { effect: $, value: N }, N; } : Mr(O)); } }, M = $ => () => be($)(vn), j = $ => O => { var y; const { release: N } = c.subscribeToTransactions(A => { var K; let { currentTree: V, previousTree: Z } = A.getState(); Z || (Z = V); const J = (K = V.atomValues.get(t)) !== null && K !== void 0 ? K : i; if (J.state === "hasValue") { var F, de, Ee, oe; const me = J.contents, pt = (F = Z.atomValues.get(t)) !== null && F !== void 0 ? F : i, dn = pt.state === "hasValue" ? pt.contents : vn; ((de = $e) === null || de === void 0 ? void 0 : de.effect) !== $ || ((Ee = $e) === null || Ee === void 0 ? void 0 : Ee.value) !== me ? O(me, dn, !V.atomValues.has(t)) : ((oe = $e) === null || oe === void 0 ? void 0 : oe.effect) === $ && ($e = null); } }, t); s.set(c, [...(y = s.get(c)) !== null && y !== void 0 ? y : [], N]); }; for (const $ of L) try { const O = $({ node: h, storeID: c.storeID, parentStoreID_UNSTABLE: c.parentStoreID, trigger: R, setSelf: be($), resetSelf: M($), onSet: j($), getPromise: fe, getLoadable: U, getInfo_UNSTABLE: ot }); if (O != null) { var I; s.set(c, [...(I = s.get(c)) !== null && I !== void 0 ? I : [], O]); } } catch (O) { re = O, xt = !0; } if (Me = !1, !(re instanceof Kt)) { var te; const $ = xt ? tu(re) : se(re) ? nu(f(c, re)) : In(Mr(re)); $.contents, d.atomValues.set(t, $), (te = c.getState().nextTree) === null || te === void 0 || te.atomValues.set(t, $); } } return C; } function m(c, d) { var R, k; return (R = (k = d.atomValues.get(t)) !== null && k !== void 0 ? k : u) !== null && R !== void 0 ? R : i; } function _(c, d) { if (d.atomValues.has(t)) return ve(d.atomValues.get(t)); if (d.nonvalidatedAtoms.has(t)) { if (u != null) return u; if (n == null) return i; const R = d.nonvalidatedAtoms.get(t), k = n.validator(R, vn); return u = k instanceof Kt ? i : In(k), u; } else return i; } function S() { u = void 0; } function w(c, d, R) { if (d.atomValues.has(t)) { const k = ve(d.atomValues.get(t)); if (k.state === "hasValue" && R === k.contents) return new Map; } else if (!d.nonvalidatedAtoms.has(t) && R instanceof Kt) return new Map; return u = void 0, new Map().set(t, In(R)); } function B() { return Nh(t) !== void 0 && o <= 0; } const h = X_({ key: t, nodeType: "atom", peek: m, get: _, set: w, init: p, invalidate: S, shouldDeleteConfigOnRelease: B, dangerouslyAllowMutability: e.dangerouslyAllowMutability, persistence_UNSTABLE: e.persistence_UNSTABLE ? { type: e.persistence_UNSTABLE.type, backButton: e.persistence_UNSTABLE.backButton } : void 0, shouldRestoreFromSnapshots: !0, retainedBy: r }); return h; } function ha(e) { const { ...t } = e, n = "default" in e ? e.default : new Promise(() => { }); return q_(n) ? lw({ ...t, default: n }) : ow({ ...t, default: n }); } function lw(e) { const t = ha({ ...e, default: vn, persistence_UNSTABLE: e.persistence_UNSTABLE === void 0 ? void 0 : { ...e.persistence_UNSTABLE, validator: r => r instanceof Kt ? r : ve(e.persistence_UNSTABLE).validator(r, vn) }, effects: e.effects, effects_UNSTABLE: e.effects_UNSTABLE }), n = dr({ key: `${e.key}__withFallback`, get: ({ get: r }) => { const o = r(t); return o instanceof Kt ? e.default : o; }, set: ({ set: r }, o) => r(t, o), cachePolicy_UNSTABLE: { eviction: "most-recent" }, dangerouslyAllowMutability: e.dangerouslyAllowMutability }); return J_(n.key, Nh(e.key)), n; } ha.value = e => new kh(e); var Ch = ha; class iw { constructor(t) { var n; Y(this, "_map", void 0), Y(this, "_keyMapper", void 0), this._map = new Map, this._keyMapper = (n = t == null ? void 0 : t.mapKey) !== null && n !== void 0 ? n : r => r; } size() { return this._map.size; } has(t) { return this._map.has(this._keyMapper(t)); } get(t) { return this._map.get(this._keyMapper(t)); } set(t, n) { this._map.set(this._keyMapper(t), n); } delete(t) { this._map.delete(this._keyMapper(t)); } clear() { this._map.clear(); } } var uw = { MapCache: iw }, sw = uw.MapCache, aw = Object.freeze({ __proto__: null, MapCache: sw }); const { LRUCache: bc } = wh, { MapCache: cw } = aw, bo = { equality: "reference", eviction: "none", maxSize: 1 / 0 }; function fw({ equality: e = bo.equality, eviction: t = bo.eviction, maxSize: n = bo.maxSize } = bo) { const r = dw(e); return pw(t, n, r); } function dw(e) { switch (e) { case "reference": return t => t; case "value": return t => yi(t); }throw b(`Unrecognized equality policy ${e}`); } function pw(e, t, n) { switch (e) { case "keep-all": return new cw({ mapKey: n }); case "lru": return new bc({ mapKey: n, maxSize: ve(t) }); case "most-recent": return new bc({ mapKey: n, maxSize: 1 }); }throw b(`Unrecognized eviction policy ${e}`); } var Lh = fw; const { setConfigDeletionHandler: hw } = Ze; function vw(e) { var t, n; const r = Lh({ equality: (t = (n = e.cachePolicyForParams_UNSTABLE) === null || n === void 0 ? void 0 : n.equality) !== null && t !== void 0 ? t : "value", eviction: "keep-all" }); return o => { var l, i; const u = r.get(o); if (u != null) return u; const { cachePolicyForParams_UNSTABLE: s, ...a } = e, f = "default" in e ? e.default : new Promise(() => { }), p = Ch({ ...a, key: `${e.key}__${(l = yi(o)) !== null && l !== void 0 ? l : "void"}`, default: typeof f == "function" ? f(o) : f, retainedBy_UNSTABLE: typeof e.retainedBy_UNSTABLE == "function" ? e.retainedBy_UNSTABLE(o) : e.retainedBy_UNSTABLE, effects: typeof e.effects == "function" ? e.effects(o) : typeof e.effects_UNSTABLE == "function" ? e.effects_UNSTABLE(o) : (i = e.effects) !== null && i !== void 0 ? i : e.effects_UNSTABLE }); return r.set(o, p), hw(p.key, () => { r.delete(o); }), p; }; } var mw = vw; const { setConfigDeletionHandler: yw } = Ze; let gw = 0; function Sw(e) { var t, n; const r = Lh({ equality: (t = (n = e.cachePolicyForParams_UNSTABLE) === null || n === void 0 ? void 0 : n.equality) !== null && t !== void 0 ? t : "value", eviction: "keep-all" }); return o => { var l; let i; try { i = r.get(o); } catch (m) { throw b(`Problem with cache lookup for selector ${e.key}: ${m.message}`); } if (i != null) return i; const u = `${e.key}__selectorFamily/${(l = yi(o, { allowFunctions: !0 })) !== null && l !== void 0 ? l : "void"}/${gw++}`, s = m => e.get(o)(m), a = e.cachePolicy_UNSTABLE, f = typeof e.retainedBy_UNSTABLE == "function" ? e.retainedBy_UNSTABLE(o) : e.retainedBy_UNSTABLE; let p; if (e.set != null) { const m = e.set; p = dr({ key: u, get: s, set: (S, w) => m(o)(S, w), cachePolicy_UNSTABLE: a, dangerouslyAllowMutability: e.dangerouslyAllowMutability, retainedBy_UNSTABLE: f }); } else p = dr({ key: u, get: s, cachePolicy_UNSTABLE: a, dangerouslyAllowMutability: e.dangerouslyAllowMutability, retainedBy_UNSTABLE: f }); return r.set(o, p), yw(p.key, () => { r.delete(o); }), p; }; } var fn = Sw; const _w = fn({ key: "__constant", get: e => () => e, cachePolicyForParams_UNSTABLE: { equality: "reference" } }); function ww(e) { return _w(e); } var Rw = ww; const Ew = fn({ key: "__error", get: e => () => { throw b(e); }, cachePolicyForParams_UNSTABLE: { equality: "reference" } }); function Tw(e) { return Ew(e); } var kw = Tw; function Nw(e) { return e; } var Cw = Nw; const { loadableWithError: Ah, loadableWithPromise: xh, loadableWithValue: Ph } = _o; function gi(e, t) { const n = Array(t.length).fill(void 0), r = Array(t.length).fill(void 0); for (const [o, l] of t.entries()) try { n[o] = e(l); } catch (i) { r[o] = i; } return [n, r]; } function Lw(e) { return e != null && !se(e); } function Si(e) { return Array.isArray(e) ? e : Object.getOwnPropertyNames(e).map(t => e[t]); } function os(e, t) { return Array.isArray(e) ? t : Object.getOwnPropertyNames(e).reduce((n, r, o) => ({ ...n, [r]: t[o] }), {}); } function qn(e, t, n) { const r = n.map((o, l) => o == null ? Ph(t[l]) : se(o) ? xh(o) : Ah(o)); return os(e, r); } function Aw(e, t) { return t.map((n, r) => n === void 0 ? e[r] : n); } const xw = fn({ key: "__waitForNone", get: e => ({ get: t }) => { const n = Si(e), [r, o] = gi(t, n); return qn(e, r, o); }, dangerouslyAllowMutability: !0 }), Pw = fn({ key: "__waitForAny", get: e => ({ get: t }) => { const n = Si(e), [r, o] = gi(t, n); return o.some(l => !se(l)) ? qn(e, r, o) : new Promise(l => { for (const [i, u] of o.entries()) se(u) && u.then(s => { r[i] = s, o[i] = void 0, l(qn(e, r, o)); }).catch(s => { o[i] = s, l(qn(e, r, o)); }); }); }, dangerouslyAllowMutability: !0 }), Mw = fn({ key: "__waitForAll", get: e => ({ get: t }) => { const n = Si(e), [r, o] = gi(t, n); if (o.every(i => i == null)) return os(e, r); const l = o.find(Lw); if (l != null) throw l; return Promise.all(o).then(i => os(e, Aw(r, i))); }, dangerouslyAllowMutability: !0 }), $w = fn({ key: "__waitForAllSettled", get: e => ({ get: t }) => { const n = Si(e), [r, o] = gi(t, n); return o.every(l => !se(l)) ? qn(e, r, o) : Promise.all(o.map((l, i) => se(l) ? l.then(u => { r[i] = u, o[i] = void 0; }).catch(u => { r[i] = void 0, o[i] = u; }) : null)).then(() => qn(e, r, o)); }, dangerouslyAllowMutability: !0 }), Iw = fn({ key: "__noWait", get: e => ({ get: t }) => { try { return dr.value(Ph(t(e))); } catch (n) { return dr.value(se(n) ? xh(n) : Ah(n)); } }, dangerouslyAllowMutability: !0 }); var Vw = { waitForNone: xw, waitForAny: Pw, waitForAll: Mw, waitForAllSettled: $w, noWait: Iw }; const { RecoilLoadable: Dw } = _o, { DefaultValue: zw } = Ze, { RecoilRoot: Uw, useRecoilStoreID: Ow } = Bt, { isRecoilValue: Fw } = ar, { retentionZone: Bw } = ii, { freshSnapshot: jw } = di, { useRecoilState: Ww, useRecoilState_TRANSITION_SUPPORT_UNSTABLE: Hw, useRecoilStateLoadable: Kw, useRecoilValue: Gw, useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: Qw, useRecoilValueLoadable: Yw, useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: Zw, useResetRecoilState: bw, useSetRecoilState: Xw } = u1, { useGotoRecoilSnapshot: Jw, useRecoilSnapshot: qw, useRecoilTransactionObserver: eR } = hh, { useRecoilCallback: tR } = gh, { noWait: nR, waitForAll: rR, waitForAllSettled: oR, waitForAny: lR, waitForNone: iR } = Vw; var No = { DefaultValue: zw, isRecoilValue: Fw, RecoilLoadable: Dw, RecoilEnv: mr, RecoilRoot: Uw, useRecoilStoreID: Ow, useRecoilBridgeAcrossReactRoots_UNSTABLE: I1, atom: Ch, selector: dr, atomFamily: mw, selectorFamily: fn, constSelector: Rw, errorSelector: kw, readOnlySelector: Cw, noWait: nR, waitForNone: iR, waitForAny: lR, waitForAll: rR, waitForAllSettled: oR, useRecoilValue: Gw, useRecoilValueLoadable: Yw, useRecoilState: Ww, useRecoilStateLoadable: Kw, useSetRecoilState: Xw, useResetRecoilState: bw, useGetRecoilValueInfo_UNSTABLE: L1, useRecoilRefresher_UNSTABLE: a_, useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: Zw, useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: Qw, useRecoilState_TRANSITION_SUPPORT_UNSTABLE: Hw, useRecoilCallback: tR, useRecoilTransaction_UNSTABLE: h_, useGotoRecoilSnapshot: Jw, useRecoilSnapshot: qw, useRecoilTransactionObserver_UNSTABLE: eR, snapshot_UNSTABLE: jw, useRetain: aa, retentionZone: Bw }, uR = No.RecoilRoot, Mh = No.atom, $h = No.useRecoilValue, Ih = No.useRecoilState, va = No.useSetRecoilState; const Co = Mh({ key: "inputs", default: cR(), effects_UNSTABLE: [({ onSet: e }) => e(aR)] }), Vh = Mh({ key: "deleted", default: [] }); function sR(e) { return [...new Intl.Segmenter("ja", { granularity: "grapheme" }).segment(e)].length; } function aR(e) { localStorage.setItem("inputs", JSON.stringify(e)); } function cR() {
    const e = localStorage.getItem("inputs"); let t = "1行目"; for (let n = 2; n < 32; n++)t += `
${n}行目`; if (e != null) try { return JSON.parse(e); } catch { } return [{
      title: "😀これはサンプルです", text: `テキストテキストテキストテキスト
テキストテキスト`}, { title: "✨タイトル１", text: "" }, { title: "🌒適当なタイトル", text: "展開しなくてもテキストが一部表示されます" }, { title: "🐙ローカルストレージに保存されます", text: t }];
  } function fR(e) { const { state: t, index: n } = e, [, r] = Ih(Co), o = va(Vh), [l, i] = er.useState(!1), u = f => { r(p => { const m = p.slice(0); return m[n] = f, m; }); }, s = () => { r(f => { const p = f.slice(0); return p.splice(n, 1), p; }), o(f => { const p = f.slice(0); return p.push(t), p; }); }, a = sR(t.text); return Q.jsxs("div", { className: "format-box", children: [Q.jsxs("div", { className: "format-flex-container", children: [Q.jsxs("div", { style: { minWidth: "5.5em" }, children: ["文字数:", a] }), Q.jsx("input", { style: { flex: 1, marginRight: "0.6em" }, type: "text", placeholder: "テンプレートの名称", value: t.title, onChange: f => u({ title: f.target.value, text: t.text }) })] }), Q.jsxs("div", { className: "format-flex-container button-container", children: [Q.jsxs("button", { className: "copy-button", onClick: async () => { navigator.clipboard.writeText(t.text); }, children: [Q.jsx("span", { className: "material-symbols-outlined", children: "assignment" }), "コピー"] }), Q.jsxs("button", { className: "delete-button", onClick: s, children: [Q.jsx("span", { className: "material-symbols-outlined", children: "delete" }), "削除"] })] }), Q.jsxs("details", { open: l, onToggle: () => i(!l), children: [Q.jsx("summary", { className: "content-dep", children: l ? "[クリックで閉じます]" : `[クリックで開きます]　${dR(t.text)}` }), Q.jsx("textarea", { style: { fontSize: "1rem", boxSizing: "border-box", width: "100%", height: 200, resize: "vertical" }, value: t.text, onChange: f => u({ title: t.title, text: f.target.value }), placeholder: "定型文を入力して下さい。[コピー] ボタンで内容をコピーできます" })] })] }); } function dR(e) { return e.length <= 20 ? e : `${e.substring(0, 20)}...`; } function pR() { const e = va(Co), [t, n] = Ih(Vh), r = l => { e(i => l === "first" ? [{ text: "", title: "" }, ...i] : [...i, { text: "", title: "" }]); }, o = () => { if (t.length === 0) return; const l = t[t.length - 1]; n(i => { const u = i.slice(0); return u.splice(u.length - 1), u; }), e(i => [...i, l]); }; return Q.jsx(Q.Fragment, { children: Q.jsxs("div", { style: { display: "flex", height: 30 }, children: [Q.jsxs("button", { className: "add-button", onClick: () => r("first"), children: [Q.jsx("span", { className: "material-symbols-outlined", children: "first_page" }), "最初に追加"] }), Q.jsxs("button", { className: "add-button", onClick: () => r("last"), children: ["最後に追加", Q.jsx("span", { className: "material-symbols-outlined", children: "last_page" })] }), Q.jsxs("button", { className: "restore-button", onClick: o, disabled: t.length === 0, children: [Q.jsx("span", { className: "material-symbols-outlined", children: "restore_from_trash" }), "削除を戻す ", t.length, "件"] })] }) }); } function hR() { const e = $h(Co); return Q.jsxs(Q.Fragment, { children: [Q.jsx(pR, {}), Q.jsx("div", { className: "format-box-container", children: e.map((t, n) => Q.jsx(fR, { state: t, index: n }, n)) }), Q.jsx(vR, {})] }); } function vR() { const [e, t] = er.useState(""), n = va(Co), [r, o] = er.useState(!1); return Q.jsxs("div", { style: { paddingTop: "2rem", fontSize: "1.5rem" }, children: [Q.jsxs("details", { className: "save-load", open: r, onToggle: async l => { o(!r), await yR(0); const i = l.target; i.open && i.scrollIntoView(!0); }, children: [Q.jsx("summary", { className: "content-dep", children: "データを出力する" }), r ? Q.jsx(mR, {}) : void 0] }), Q.jsxs("details", { className: "save-load", onToggle: l => { const i = l.target; i.open && i.scrollIntoView(!0); }, children: [Q.jsx("summary", { className: "content-dep", children: "データを読み込む" }), Q.jsxs("div", { style: { paddingLeft: "1rem" }, children: ["入力されたテキストを元に現在の内容を上書きします", Q.jsx("br", {}), "「データを出力する」で出力したテキストを入力して下さい"] }), Q.jsx("button", { style: { marginBottom: "0.5rem" }, className: "danger-color", onClick: () => n(JSON.parse(e)), children: "テキストから読み込む ※全ての内容が上書きされます" }), Q.jsx("textarea", { style: { width: "100%", height: 200, resize: "vertical" }, value: e, onChange: l => t(l.target.value), placeholder: "ここにコピーしたテキストを貼り付けて下さい" })] })] }); } function mR() { const e = $h(Co), t = JSON.stringify(e, null, 2); return Q.jsxs(Q.Fragment, { children: [Q.jsxs("div", { style: { paddingLeft: "1rem" }, children: ["現在の内容をテキストで出力します", Q.jsx("br", {}), "出力したテキストを「データを読み込む」に入力することで端末間でデータを移動できます"] }), Q.jsx("button", { style: { marginBottom: "0.5rem" }, className: "safe-color", onClick: () => navigator.clipboard.writeText(t), children: "コピーする" }), Q.jsx("textarea", { style: { width: "100%", height: 200, resize: "vertical" }, value: t, disabled: !0 })] }); } const yR = e => new Promise(t => setTimeout(t, e)); ru.createRoot(document.getElementById("root")).render(Q.jsx(ce.StrictMode, { children: Q.jsx(uR, { children: Q.jsx(hR, {}) }) }));

</script>

</html>